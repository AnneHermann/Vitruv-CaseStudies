import static extension tools.vitruv.domains.java.util.JavaPersistenceHelper.*;
import org.apache.log4j.PropertyConfigurator
import org.emftext.language.java.types.TypesFactory
import org.emftext.language.java.parameters.ParametersFactory
import static extension tools.vitruv.applications.umljava.java2uml.JavaToUmlHelper.*;

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml
import "http://www.emftext.org/java" as java

reactions: JavaToUml
in reaction to changes in java
execute actions in uml

reaction JavaClassCreated {
    after element java::Class created and inserted in java::CompilationUnit[classifiers]
    call createUmlClass(newValue)
}

routine createUmlClass(java::Class jClass) {
    action {
        val uClass = create uml::Class and initialize {
            uClass.name = jClass.name;
        }
        val uModel = create uml::Model and initialize {
            uModel.packagedElements += uClass;
        }
        add correspondence between uClass and jClass
        add correspondence between uClass and jClass.eContainer //TODO ist das die CompuUnit?
    }
}

//java::ConcreteClassifier = {Annotation, Class, Interface, Enumeration}
reaction JavaClassifierRenamed {
    after attribute replaced at java::ConcreteClassifier[name]
    call renameUmlClassifier(affectedEObject)
}

//TODO uml::Classifer = {Class, Interface, Enumeration, und noch vieles mehr <-- Problem?}
routine renameUmlClassifier(java::ConcreteClassifier jClass) {
    match {
        val uClass = retrieve uml::Classifier corresponding to jClass
        val jCompUnit = retrieve java::CompilationUnit corresponding to uClass
    }
    action {
        update uClass {
            uClass.name = jClass.name;
        }
        update jCompUnit {
            jCompUnit.name = jClass.name;
        }
    }
}

reaction JavaClassifierDeleted {
    after element java::ConcreteClassifier deleted and removed from java::CompilationUnit[classifiers]
    call deleteUmlClassifier(oldValue, affectedEObject)
}

routine deleteUmlClassifier(java::ConcreteClassifier jClass, java::CompilationUnit jCompUnit) {
    match {
        val uClass = retrieve uml::Classifier corresponding to jClass
    }
    action {
        delete uClass
        delete jCompUnit
    }
}

reaction JavaClassMadePublic {
    after element java::Public created and inserted in java::Class[annotationsAndModifiers]
    call changeUmlClassVisibility(affectedEObject, newValue)
}
reaction JavaClassMadePrivate {
    after element java::Private created and inserted in java::Class[annotationsAndModifiers]
    call changeUmlClassVisibility(affectedEObject, newValue)
}
reaction JavaClassMadeProtected {
    after element java::Protected created and inserted in java::Class[annotationsAndModifiers]
    call changeUmlClassVisibility(affectedEObject, newValue)
}

routine changeUmlClassVisibility(java::Class jClass, java::Modifier mod) {
    match {
        val uClass = retrieve uml::Class corresponding to jClass
    }
    action {
        update uClass {
            uClass.visibility = getUmlVisibilityKind(mod);
        }
    }
}

reaction JavaClassMadeAbstract {
    after element java::Abstract created and inserted in java::Class[annotationsAndModifiers]
    call setUmlClassAbstract(affectedEObject, 1)
}

reaction JavaClassMadeNonAbstract {
    after element java::Abstract deleted and removed from java::Class[annotationsAndModifiers]
    call setUmlClassAbstract(affectedEObject, 0)
}

// isAbstract: Boolean geht nicht?
// 1 = true
// 0 = false
routine setUmlClassAbstract(java::Class jClass, Int isAbstract) {
    match {
        val uClass = retrieve uml::Class corresponding to jClass
    }
    action {
        update uClass {
            if (isAbstract == 1) {
                uClass.isAbstract = true;
            } else if (isAbstract == 0) {
                uClass.isAbstract = false;
            } else {
                //Fehler
            }
        }
    }
}

reaction JavaClassMadeFinal {
    after element java::Final created and inserted in java::Class[annotationsAndModifiers]
    call setUmlClassAbstract(affectedEObject, 1)
}

reaction JavaClassMadeNonFinal {
    after element java::Final deleted and removed from java::Class[annotationsAndModifiers]
    call setUmlClassAbstract(affectedEObject, 0)
}

routine setUmlClassFinal(java::Class jClass, Int isFinal) {
    match {
        val uClass = retrieve uml::Class corresponding to jClass
    }
    action {
        update uClass {
            if (isFinal == 1) {
                uClass.isFinalSpecialization = true;
            } else if (isFinal == 0) {
                uClass.isFinalSpecialization = false;
            } else {
                //Fehler
            }
        }
    }
}

//FÃ¼r Interface & ClassMethods
reaction JavaMethodCreated {
    after element java::Method created and inserted in java::ConcreteClassifier[members]
    call createUmlMethod(newValue, affectedEObject)
}

routine createUmlMethod(java::Method jMeth, java::ConcreteClassifier jClass) {
    match {
        val uClass = retrieve uml::Class corresponding to jClass
    }
    action {
        val uMeth = create uml::Operation and initialize {
            uMeth.name = jMeth.name;
            //uMeth.type
        }
        add correspondence between uMeth and jMeth
        update uClass {
            uClass.ownedOperations += uMeth;
        }
    }
}

reaction JavaMethodRenamed {
    after attribute replaced at java::Method[name]
    call renameUmlMethod(affectedEObject)
}

routine renameUmlMethod(java::Method jMeth) {
    match {
        val uMeth = retrieve uml::Operation corresponding to jMeth
    }
    action {
        update uMeth {
            uMeth.name = jMeth.name;
        }
    }
}

reaction JavaMethodDeleted {
    after element java::Method deleted and removed from java::ConcreteClassifier[members]
    call deleteUmlMethod(oldValue)
}

routine deleteUmlMethod(java::Method jMeth) {
    match {
        val uMeth = retrieve uml::Operation corresponding to jMeth
    }
    action {
        delete uMeth
    }
}