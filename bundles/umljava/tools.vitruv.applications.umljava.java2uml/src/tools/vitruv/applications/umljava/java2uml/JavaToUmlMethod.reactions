import static tools.vitruv.applications.umljava.util.JavaUtil.*;
import static tools.vitruv.applications.umljava.util.UmlUtil.*;
import static tools.vitruv.applications.umljava.java2uml.JavaToUmlHelper.*;
import "http://www.eclipse.org/uml2/5.0.0/UML" as uml
import "http://www.emftext.org/java" as java

reactions: JavaToUmlmethod
in reaction to changes in java
execute actions in uml

reaction JavaClassMethodCreated {
    after element java::ClassMethod created and inserted in java::Class[members]
    call createUmlClassMethod(newValue, affectedEObject)
}

routine createUmlClassMethod(java::ClassMethod jMeth, java::Class jClass) {
    match {
        val uClass = retrieve uml::Class corresponding to jClass
        val customType = retrieve optional uml::Class corresponding to getClassifierfromTypeRef(jMeth.typeReference)
    }
    action {
        val uMeth = create uml::Operation and initialize {
            uMeth.name = jMeth.name;
        }
        add correspondence between uMeth and jMeth
        update uClass {
            uClass.ownedOperations += uMeth;
        }
    }
}

reaction JavaInterfaceMethodCreated {
    after element java::InterfaceMethod created and inserted in java::Interface[members]
    call createUmlInterfaceMethod(newValue, affectedEObject)
}

routine createUmlInterfaceMethod(java::InterfaceMethod jMeth, java::Interface jI) {
    match {
        val uI = retrieve uml::Interface corresponding to jI
        val customType = retrieve optional uml::Class corresponding to getClassifierfromTypeRef(jMeth.typeReference)
    }
    action {
        val uMeth = create uml::Operation and initialize {
            uMeth.name = jMeth.name;
        }
        add correspondence between uMeth and jMeth
        update uI {
            uI.ownedOperations += uMeth;
        }
    }
}

reaction JavaMemberDeleted {
    after element java::Member deleted and removed from java::ConcreteClassifier[members]
    call deleteUmlMethod(oldValue)
}

routine deleteUmlMethod(java::Member jMem) {
    match {
        val uMem = retrieve uml::NamedElement corresponding to jMem
    }
    action {
        delete uMem
    }
}

reaction JavaMethodMadeAbstract {
    after element java::Abstract created and inserted in java::ClassMethod[annotationsAndModifiers]
    call  {
        setUmlMethodAbstract(affectedEObject, 1)
    }
}

reaction JavaMethodMadeNonAbstract {
    after element java::Abstract deleted and removed from java::ClassMethod[annotationsAndModifiers]
    call setUmlMethodAbstract(affectedEObject, 0)
}

routine setUmlMethodAbstract(java::ClassMethod jMeth, Boolean isAbstract) {
    match {
        val uMeth = retrieve uml::Operation corresponding to jMeth
    }
    action {
        update uMeth {
            if (isAbstract == 1){
                uMeth.isAbstract = true;
            } else if (isAbstract == 0) {
                uMeth.isAbstract = false;
            } else {
                throw new IllegalArgumentException("Invalid isAbstract Value: " + isAbstract);
            }
        }
    }
}

reaction JavaElementMadeStatic {
    after element java::Static created and inserted in java::AnnotableAndModifiable[annotationsAndModifiers]
    call setUmlFeatureStatic(affectedEObject, 1)
}

reaction JavaMethodMadeNonStatic {
    after element java::Static deleted and removed from java::AnnotableAndModifiable[annotationsAndModifiers]
    call setUmlFeatureStatic(affectedEObject, 0)
}

routine setUmlFeatureStatic(java::AnnotableAndModifiable jElem, Integer isStatic) {
    match {
        val uFeature = retrieve uml::Feature corresponding to jElem
    }
    action {
        update uFeature {
            if (isStatic == 1) {
                uFeature.isStatic = true;
            } else if (isStatic == 0) {
                uFeature.isStatic = false;
            } else {
                throw new IllegalArgumentException("Invalid isStatic Value: " + isStatic);
            }
        }
    }
}

reaction JavaParameterCreated {
    after element java::OrdinaryParameter created and inserted in java::Method[parameters]
    call createUmlParameter(affectedEObject, newValue)
}

routine createUmlParameter(java::Method jMeth, java::OrdinaryParameter jParam) {
    match {
        val uMeth = retrieve uml::Operation corresponding to jMeth
        val customType = retrieve optional uml::Class corresponding to getClassifierfromTypeRef(jParam.typeReference)
    }
    action {
        val uParam = create uml::Parameter and initialize {
            uParam.name = jParam.name;
        }
        add correspondence between uParam and jParam
        update uMeth {
            uMeth.ownedParameters += uParam
        }
    }
}

reaction JavaParameterDeleted {
    after element java::OrdinaryParameter deleted and removed from java::Method[parameters]
    call deleteJavaParameter(oldValue)
}

routine deleteJavaParameter(java::OrdinaryParameter jParam) {
    match {
        val uParam = retrieve uml::Parameter corresponding to jParam
    }
    action{
        delete uParam         
    }
}

reaction JavaParameterTypeChanged {
    after element java::TypeReference replaced at java::OrdinaryParameter[typeReference]
    call changeUmlParameterType(affectedEObject, newValue)
}

routine changeUmlParameterType(java::OrdinaryParameter jParam, java::TypeReference jType) {
    match {
        val uParam = retrieve uml::Parameter corresponding to jParam
        val customType = retrieve optional uml::Class corresponding to getClassifierfromTypeRef(jType)
    }
    action {
        update uParam {
            uParam.type = getUmlType(jType, customType, getUmlModel(correspondenceModel, userInteracting));
        }
    }
}

reaction JavaReturnTypeChanged {
    after element java::TypeReference replaced at java::Method[typeReference]
    call changeUmlReturnType(affectedEObject, newValue)
}

routine changeUmlReturnType(java::Method jMeth, java::TypeReference jType) {
    match {
        val uMeth = retrieve uml::Operation corresponding to jMeth
        val customType = retrieve optional uml::Class corresponding to getClassifierfromTypeRef(jType)
    }
     action {
         update uMeth {
             uMeth.type = getUmlType(jType, customType, getUmlModel(correspondenceModel, userInteracting))
         }
     }
}