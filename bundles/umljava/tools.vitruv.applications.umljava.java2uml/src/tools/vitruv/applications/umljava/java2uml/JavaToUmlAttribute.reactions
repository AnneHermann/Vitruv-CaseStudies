import static tools.vitruv.applications.umljava.util.java.JavaTypeUtil.*;
import static tools.vitruv.applications.umljava.java2uml.JavaToUmlHelper.*;
import "http://www.eclipse.org/uml2/5.0.0/UML" as uml
import "http://www.emftext.org/java" as java

reactions: JavaToUmlAttribute
in reaction to changes in Java
execute actions in UML

reaction JavaAttributeCreated {
    after element java::Field created and inserted in java::ConcreteClassifier[members]
    call {
        if (affectedEObject instanceof org.emftext.language.java.classifiers.Class) {
            createUmlAttributeInClass(affectedEObject, newValue)
        } else if (affectedEObject instanceof org.emftext.language.java.classifiers.Enumeration) {
            createUmlAttributeInEnum(affectedEObject, newValue)
        } else {
            logger.warn(affectedEObject + " is neither a Class nor a Enum. JavaAttributeCreated-Reaction not executed.")
        }
    }
}

routine createUmlAttributeInClass(java::Class jClass, java::Field jAttr) {
    match {
        val uClass = retrieve uml::Class corresponding to jClass
    }
    action {
        val uAttr = create uml::Property and initialize {
            uAttr.name = jAttr.name;
        }
        add correspondence between uAttr and jAttr
        update uClass {
            uClass.ownedAttributes += uAttr;
        }
    }
}
//UML-Enumeration and UMl-Class don't have a common superclass for "having ownedAttributes".
//Therefore we implemented two separate routines
routine createUmlAttributeInEnum(java::Enumeration jEnum, java::Field jAttr) {
    match {
        val uEnum = retrieve uml::Enumeration corresponding to jEnum
    }
    action {
        val uAttr = create uml::Property and initialize {
            uAttr.name = jAttr.name;
        }
        add correspondence between uAttr and jAttr
        update uEnum {
            uEnum.ownedAttributes += uAttr;
        }
    }
}

reaction JavaAttributeTypeChanged {
    after element java::TypeReference replaced at java::Field[typeReference]
    call {
        changeUmlAttributeType(affectedEObject, newValue)
        }
}

routine changeUmlAttributeType(java::Field jAttr, java::TypeReference jType) {
    match {
        val uAttr = retrieve uml::Property corresponding to jAttr
        
    }
    action {
        update uAttr {
            uAttr.type = getUmlType(jType, getUmlModel(correspondenceModel, userInteracting), correspondenceModel)
        }
    }
}

reaction JavaAttributeMadeFinal {
    after element java::Final created and inserted in java::Field[annotationsAndModifiers]
    call setUmlAttributeFinal(affectedEObject, true)
}

reaction JavaAttributeMadeNonFinal {
    after element java::Final deleted and removed from java::Field[annotationsAndModifiers]
    call setUmlAttributeFinal(affectedEObject, false)
}

routine setUmlAttributeFinal(java::Field jAttr, Boolean isFinal) {
    match {
        val uAttr = retrieve uml::Property corresponding to jAttr 
    }
    action {
        update uAttr {
            uAttr.isReadOnly = isFinal
        }
    }
}