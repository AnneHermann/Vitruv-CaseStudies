import org.eclipse.uml2.uml.VisibilityKind

import org.emftext.language.java.modifiers.*;
import org.emftext.language.java.classifiers.Interface;
import org.apache.log4j.PropertyConfigurator
import static tools.vitruv.applications.umljava.util.java.JavaTypeUtil.*;
import static tools.vitruv.applications.umljava.util.uml.UmlClassifierAndPackageUtil.*;
import static tools.vitruv.applications.umljava.java2uml.JavaToUmlHelper.*;
import org.emftext.language.java.classifiers.ConcreteClassifier

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml
import "http://www.emftext.org/java" as java

reactions: JavaToUmlClassifier
in reaction to changes in Java
execute actions in UML

reaction JavaClassCreated {
    after element java::Class created and inserted in java::CompilationUnit[classifiers]
    call createUmlClass(newValue)

}

routine createUmlClass(java::Class jClass) {
    action {
        val uClass = create uml::Class and initialize {
            uClass.name = jClass.name;
        }
        call {
        	addUmlElementToRootModel(uClass, jClass)
        }
        add correspondence between uClass and jClass
        add correspondence between uClass and jClass.eContainer
    }
}

routine addUmlElementToRootModel(uml::PackageableElement uPackageable, EObject persistedObject) {
	action {
		call {
			val uModel = getUmlModel(correspondenceModel, userInteracting)
            uModel.packagedElements += uPackageable;
            persistProjectRelative(persistedObject, uModel, rootModelFile)
		}
	}
}

reaction JavaInterfaceCreated {
    after element java::Interface created and inserted in java::CompilationUnit[classifiers]
    call createUmlInterface(newValue)
}

routine createUmlInterface(java::Interface jInterface) {
    action {
        val uInterfacenterface = create uml::Interface and initialize {
            uInterfacenterface.name = jInterface.name;
            uInterfacenterface.visibility = VisibilityKind.PUBLIC_LITERAL
        }
        call {
           addUmlElementToRootModel(uInterfacenterface, jInterface)
        }
        add correspondence between uInterfacenterface and jInterface
        add correspondence between uInterfacenterface and jInterface.eContainer
    }
}

reaction JavaCompUnitDeleted {
    after element java::CompilationUnit removed as root
    call deleteUmlClassifier(oldValue.classifiers.head, oldValue)
}

reaction JavaClassifierDeleted {
    after element java::ConcreteClassifier deleted and removed from java::CompilationUnit[classifiers]
    call deleteUmlClassifier(oldValue, affectedEObject)
}

routine deleteUmlClassifier(java::ConcreteClassifier jClass, java::CompilationUnit jCompUnit) {
    match {
        val uClass = retrieve uml::Classifier corresponding to jClass
    }
    action {
        delete uClass
        delete jCompUnit
    }
}

reaction JavaElementVisibilityChanged {
    after element java::Modifier created and inserted in java::AnnotableAndModifiable[annotationsAndModifiers]
    with newValue instanceof Public || newValue instanceof Private || newValue instanceof Protected
    call changeUmlNamedElementVisibility(affectedEObject, newValue)
}

reaction JavaElementMadePackagePrivate {
    after element java::Modifier deleted and removed from java::Class[annotationsAndModifiers]
    with oldValue instanceof Private
    || oldValue instanceof Public
    || oldValue instanceof Protected
    call changeUmlNamedElementVisibility(affectedEObject, null)
}

routine changeUmlNamedElementVisibility(java::AnnotableAndModifiable jElem, java::Modifier mod) {
    match {
        val uElem = retrieve uml::NamedElement corresponding to jElem
    }
    action {
        update uElem {
            uElem.visibility = getUmlVisibilityKind(mod);
        }
    }
}

reaction JavaClassMadeAbstract {
    after element java::Abstract created and inserted in java::Class[annotationsAndModifiers]
    call setUmlClassAbstract(affectedEObject, true)
}

reaction JavaClassMadeNonAbstract {
    after element java::Abstract deleted and removed from java::Class[annotationsAndModifiers]
    call setUmlClassAbstract(affectedEObject, false)
}

routine setUmlClassAbstract(java::Class jClass, Boolean isAbstract) {
    match {
        val uClass = retrieve uml::Class corresponding to jClass
    }
    action {
        update uClass {
            uClass.isAbstract = isAbstract
        }
    }
}

reaction JavaSuperClassChanged {
    after element java::TypeReference replaced at java::Class[^extends] //TODO Funktioniert das, wenn vorher nichts drin stand?
    call  {
        addUmlSuperClassifier(affectedEObject, getClassifierFromTypeReference(newValue))
    }
}

reaction JavaSuperClassRemoved {
    after element java::TypeReference removed from java::Class[^extends]
    call clearUmlSuperClassifiers(affectedEObject)
}

routine addUmlSuperClassifier(java::ConcreteClassifier jClass, java::Classifier jSuperClassifier) {
    match {
        val uClass = retrieve uml::Classifier corresponding to jClass
        val uSuperClassifier = retrieve uml::Classifier corresponding to jSuperClassifier
    }
    action {
        update uClass {
            uClass.generals += uSuperClassifier;
        }
    }
}

routine clearUmlSuperClassifiers(java::ConcreteClassifier jClass) {
    match {
         val uClass = retrieve uml::Class corresponding to jClass
    }
    action {
        update uClass {
            uClass.generalizations.clear;
        }
    }
}

reaction JavaSuperInterfaceAdded {
    after element java::TypeReference inserted in java::Interface[^extends]
    call addUmlSuperClassifier(affectedEObject, getClassifierFromTypeReference(newValue))
}

reaction JavaSuperInterfaceRemoved {
    after element java::TypeReference removed from java::Interface[^extends]
    call removeUmlSuperInterface(affectedEObject, getClassifierFromTypeReference(oldValue))
}

routine removeUmlSuperInterface(java::Interface jI, java::Classifier jSuper) {
    match {
        val uInterface = retrieve uml::Interface corresponding to jI
        val uSuper = retrieve uml::Interface corresponding to jSuper
    }
    action {
        update uInterface {
            removeClassifierFromIterator(uInterface.generals.iterator, uSuper)
        }
    }
}

reaction JavaClassImplementAdded {
    after element java::TypeReference created and inserted in java::Class[implements]
    call addUmlClassImplement(affectedEObject, getClassifierFromTypeReference(newValue) as Interface)
}

routine addUmlClassImplement(java::Class jClass, java::Interface jI) {
    match {
        val uClass = retrieve uml::Class corresponding to jClass
        val uInterface = retrieve uml::Interface corresponding to jI
    }
    action {
        update uClass {
            uClass.createInterfaceRealization(DEFAULT_INTERFACEREALIZATION_NAME + uInterface.name, uInterface)
        }
    }
}

reaction JavaClassImplementRemoved {
    after element java::TypeReference removed from java::Class[implements]
    call removeUmlClassImplement(affectedEObject, getClassifierFromTypeReference(oldValue) as Interface)
}

routine removeUmlClassImplement(java::Class jClass, java::Interface jI) {
    match {
        val uClass = retrieve uml::Class corresponding to jClass
        val uInterface = retrieve uml::Interface corresponding to jI
    }
    action {
        update uClass {
            removeClassifierFromIterator(uClass.implementedInterfaces.iterator, uInterface)
        }
    }
}

reaction JavaClassMadeFinal {
    after element java::Final created and inserted in java::Class[annotationsAndModifiers]
    call setUmlClassFinal(affectedEObject, true)
}

reaction JavaClassMadeNonFinal {
    after element java::Final deleted and removed from java::Class[annotationsAndModifiers]
    call setUmlClassFinal(affectedEObject, false)
}

routine setUmlClassFinal(java::Class jClass, Boolean isFinal) {
    match {
        val uClass = retrieve uml::Class corresponding to jClass
    }
    action {
        update uClass {
            uClass.isFinalSpecialization = isFinal
        }
    }
}

reaction JavaNamedElementRenamed {
    after attribute replaced at java::NamedElement[name]
    call renameUmlNamedElement(affectedEObject)
}

routine renameUmlNamedElement(java::NamedElement jElement) {
    match {
        val uElement = retrieve uml::NamedElement corresponding to jElement
    }
    action {
        update uElement {
            uElement.name = jElement.name;
        }
    }
}

reaction JavaPackageCreated {
	after element java::Package inserted as root
	call createUmlPackage(newValue)
}

routine createUmlPackage(java::Package jPackage) {
	action {
		val uPackage = create uml::Package and initialize {
			uPackage.name = jPackage.name
		}
		add correspondence between uPackage and jPackage
		call {
			addUmlElementToRootModel(uPackage, jPackage)
		}
	}
}

reaction JavaCompilationUnitInsertedInPackage {
    after element java::CompilationUnit inserted in java::Package[compilationUnits]
    call addUmlPackageOfClass(affectedEObject, newValue.classifiers.head)
}

reaction JavaCompilationUnitRemovedFromPackage {
    after element java::CompilationUnit removed from java::Package[compilationUnits]
    call removeUmlPackageOfClass(affectedEObject, oldValue.classifiers.head)
}

routine addUmlPackageOfClass(java::Package jPackage, java::ConcreteClassifier jClassifier) {
    match {
        val uClassifier = retrieve uml::Classifier corresponding to jClassifier
        val uPackage = retrieve uml::Package corresponding to jPackage
    }
    action {
        update uPackage {
            uPackage.packagedElements += uClassifier
        }
    }
}

routine removeUmlPackageOfClass(java::Package jPackage, java::ConcreteClassifier jClassifier) {
    match {
        val uClassifier = retrieve uml::Classifier corresponding to jClassifier
        val uPackage = retrieve uml::Package corresponding to jPackage
    }
    action {
        update uPackage {
            removePackagedElementFromPackage(uPackage, uClassifier)
        }
    }
}
