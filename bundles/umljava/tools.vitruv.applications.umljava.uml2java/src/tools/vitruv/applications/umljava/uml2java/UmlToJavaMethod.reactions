import org.eclipse.uml2.uml.ParameterDirectionKind
import org.emftext.language.java.types.TypesFactory
import static tools.vitruv.applications.umljava.uml2java.UmlToJavaHelper.*
import static extension tools.vitruv.applications.umljava.util.java.JavaModifierUtil.*

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml
import "http://www.emftext.org/java" as java

reactions: UmlToJavaMethod
in reaction to changes in UML
execute actions inJava

reaction UmlMethodCreated {
    after element uml::Operation created and inserted in uml::Class[ownedOperation]
    call {
        createJavaMethod(affectedEObject, newValue)       
    }
}

routine createJavaMethod(uml::Class uClass, uml::Operation umlOp) {
    match {
        
        val javaClass = retrieve java::Class corresponding to uClass
        val customTypeClass = retrieve optional java::Class corresponding to umlOp.type
    }
    action {
        val javaMethod = create java::ClassMethod and initialize {
            javaMethod.name = umlOp.name;
            setJavaVisibility(javaMethod, umlOp.visibility)
            javaMethod.typeReference = createTypeReference(umlOp.type, customTypeClass)
        }
        update javaClass {
            javaClass.members += javaMethod;
        }
        add correspondence between umlOp and javaMethod
    }
}

reaction UmlClassMethodDeleted {
    after element uml::Operation deleted and removed from uml::Class[ownedOperation]
    call deleteJavaMethod(oldValue)
}
//uml::Interface and uml::Class dont have a common superClass for "having ownedOperation",
//so we need two separate reactions
reaction UmlInterfaceMethodDeleted {
    after element uml::Operation deleted and removed from uml::Interface[ownedOperation]
    call deleteJavaMethod(oldValue)
}

routine deleteJavaMethod(uml::Operation umlOp) {
    match {
        val jMeth = retrieve java::Method corresponding to umlOp
    }
    action {
        delete jMeth
    }
}

reaction UmlParameterCreated {
    after element uml::Parameter created and inserted in uml::Operation[ownedParameter]
    with newValue.direction != ParameterDirectionKind.RETURN_LITERAL && newValue.name != null
    call createJavaParameter(affectedEObject, newValue)

}

routine createJavaParameter(uml::Operation uMeth, uml::Parameter umlParam) {
    match {
        val javaMethod = retrieve java::Method corresponding to uMeth
        val customTypeClass = retrieve optional java::Class corresponding to umlParam.type
    }
    action {
        val javaParam = create java::OrdinaryParameter and initialize {
        	if (umlParam == null) {
        		javaParam.name = "DefaultParameterName" //TODO notwendig?
        	} else {
        		javaParam.name = umlParam.name;
        	}
            
            javaParam.typeReference = createTypeReference(umlParam.type, customTypeClass)
        }
        add correspondence between javaParam and umlParam
        update javaMethod {
            javaMethod.parameters += javaParam;
        }
    }
}

reaction UmlParameterDeleted {
    after element uml::Parameter deleted and removed from uml::Operation[ownedParameter]
    with oldValue.direction != ParameterDirectionKind.RETURN_LITERAL
    call deleteJavaParameter(oldValue)
}

routine deleteJavaParameter(uml::Parameter uParam) {
    match {
        val jParam = retrieve java::OrdinaryParameter corresponding to uParam
    }
    action {
        delete jParam
    }
}

reaction UmlParameterTypeChanged {
    after element uml::Type replaced at uml::Parameter[type]
    with affectedEObject.direction != ParameterDirectionKind.RETURN_LITERAL
    call  changeJavaParameterType(affectedEObject, newValue)
}

routine changeJavaParameterType(uml::Parameter uParam, uml::Type uType) {
    match {
        val jParam = retrieve java::OrdinaryParameter corresponding to uParam
        val customClass = retrieve optional java::Class corresponding to uType
    }
    action {
        update jParam {
            jParam.typeReference = createTypeReference(uType, customClass);
        }
    }
}


reaction UmlMethodReturnTypeChanged {
    after element uml::Type replaced at uml::Parameter[type]
    with affectedEObject.direction == ParameterDirectionKind.RETURN_LITERAL
    call setJavaMethodReturnType(affectedEObject.operation)
}

reaction UmlParameterDirectionChanged {
    after attribute replaced at uml::Parameter[direction]
    call adaptJavaParametertoDirectionChange(affectedEObject.operation, affectedEObject, oldValue, newValue)
}

routine adaptJavaParametertoDirectionChange(uml::Operation uOperation, uml::Parameter uParam, plain ParameterDirectionKind as oldDirection,
	plain ParameterDirectionKind as newDirection) {
	match {
		val jMethod = retrieve java::Method corresponding to uOperation
		val jParam = retrieve optional java::OrdinaryParameter corresponding to uParam
		val customTypeClass = retrieve optional java::Class corresponding to uParam.type
	}
	action {
		update jMethod {
			if (newDirection == ParameterDirectionKind.RETURN_LITERAL) {
				jMethod.typeReference = createTypeReference(uParam.type, customTypeClass)
			} else if (oldDirection == ParameterDirectionKind.RETURN_LITERAL) {
				jMethod.typeReference = TypesFactory.eINSTANCE.createVoid
			}
		}
		
		call {
		    if (newDirection == ParameterDirectionKind.RETURN_LITERAL && jParam !== null) {
			    deleteJavaParameter(uParam)
			} else if (newDirection == ParameterDirectionKind.IN_LITERAL && jParam === null) {
			    createJavaParameter(uOperation, uParam)
			}
		}
	}
}

routine setJavaMethodReturnType(uml::Operation uOperation) {
    match {
        val javaMethod = retrieve java::Method corresponding to uOperation
        val returnType = retrieve optional java::Class corresponding to uOperation.type
    }
    action {
        update javaMethod {
            javaMethod.typeReference = createTypeReference(uOperation.type, returnType)
        }
    }
}

//uml::Feature defines static
reaction UmlFeatureMadeStatic {
    after attribute replaced at uml::Feature[isStatic]
    call setStatic(affectedEObject)
}

routine setStatic(uml::Feature uFeat) {
    match {
        val jMod = retrieve java::AnnotableAndModifiable corresponding to uFeat
    }
    action {
        val staticMod = create java::Static
        update jMod {
            jMod.static = uFeat.isStatic
        }
    }
}

reaction UmlMethodMadeAbstract {
    after attribute replaced at uml::Operation[isAbstract] 
    call setJavaMethodAbstract(affectedEObject)
}

routine setJavaMethodAbstract(uml::Operation umlOp) {
    match {
        val javaClass = retrieve java::Class corresponding to umlOp.class_
        val javaMethod = retrieve java::ClassMethod corresponding to umlOp
    }
    action {
        update javaMethod {
            javaMethod.abstract =  umlOp.abstract
        }
    }    
}

reaction UmlInterfaceMethodCreated {
    after element uml::Operation created and inserted in uml::Interface[ownedOperation]
    call createJavaInterfaceMethod(newValue)
}

routine createJavaInterfaceMethod(uml::Operation umlOp) {
    match {
        val jInterface = retrieve java::Interface corresponding to umlOp.interface
        val customTypeClass = retrieve optional java::Class corresponding to umlOp.type
    }
    action {
        val javaMethod = create java::InterfaceMethod and initialize {
            javaMethod.name = umlOp.name;
            javaMethod.typeReference = createTypeReference(umlOp.type, customTypeClass)
            javaMethod.makePublic
        }
        add correspondence between umlOp and javaMethod
        update jInterface {
            jInterface.members += javaMethod;
        }
    }
}

