import static tools.vitruv.applications.umljava.uml2java.UmlToJavaHelper.*
import static extension tools.vitruv.applications.umljava.util.java.JavaMemberAndParameterUtil.*
import static extension tools.vitruv.applications.umljava.util.java.JavaModifierUtil.*
import static extension tools.vitruv.applications.umljava.util.java.JavaTypeUtil.*
import static tools.vitruv.applications.umljava.util.java.JavaStatementUtil.*
import org.eclipse.uml2.uml.LiteralUnlimitedNatural

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml
import "http://www.emftext.org/java" as java

reactions: UmlToJavaAttribute
in reaction to changes in UML
execute actions in Java



reaction UmlAttributeCreatedInClass {
    after element uml::Property created and inserted in uml::Class[ownedAttribute]
    call {
        createJavaAttributeInClass(affectedEObject, newValue)
    }
}

routine createJavaAttributeInClass(uml::Class umlClass, uml::Property umlAttribute) {
    match {
        val javaClass = retrieve java::Class corresponding to umlClass
        val customTypeClass = retrieve optional java::Class corresponding to umlAttribute.type
    }
    action {
        val javaAttribute = create java::Field and initialize {
            javaAttribute.name = umlAttribute.name;
            javaAttribute.makePublic
        }
        update javaClass {
            javaClass.members += javaAttribute
        }
        add correspondence between umlAttribute and javaAttribute
    }
}
//We can not define one single reaction for attribute creation in enums and classes because
//They don't have a common superclass for "having ownedAttributes"
reaction UmlAttributeCreatedInEnum {
    after element uml::Property created and inserted in uml::Enumeration[ownedAttribute]
    call {
        createJavaAttributeInEnum(affectedEObject, newValue)
    }
}

routine createJavaAttributeInEnum(uml::Enumeration uEnum, uml::Property umlAttribute) {
    match {
        val jEnum = retrieve java::Enumeration corresponding to uEnum
        val customTypeClass = retrieve optional java::Class corresponding to umlAttribute.type
    }
    action {
        val javaAttribute = create java::Field and initialize {
            javaAttribute.name = umlAttribute.name;
            javaAttribute.makePublic
        }
        update jEnum {
            jEnum.members += javaAttribute
        }
        add correspondence between umlAttribute and javaAttribute
    }
}

reaction UmlAttributeDeletedFromClass {
    after element uml::Property deleted and removed from uml::Class[ownedAttribute]
    call deleteJavaAttribute(oldValue)
}

reaction UmlAttributeDeletedFromEnum {
    after element uml::Property deleted and removed from uml::Enumeration[ownedAttribute]
    call deleteJavaAttribute(oldValue)
}

routine deleteJavaAttribute(uml::Property umlAttr) {
    match {
        val jAttr = retrieve java::Field corresponding to umlAttr
    }
    action {
        call {
            removeJavaGettersOfAttribute(jAttr)
            removeJavaSettersOfAttribute(jAttr)
        }
        delete jAttr
        
    }
}

reaction UmlAttributeMadeFinal {
    after attribute replaced at uml::Property[isReadOnly]
    call setJavaAttributeFinal(affectedEObject) 
}

routine setJavaAttributeFinal(uml::Property umlAttr) {
    match {
        val jAttr = retrieve java::Field corresponding to umlAttr
    }
    action {
        update jAttr {
            jAttr.final = umlAttr.readOnly
        }
    }
}

reaction UmlAttributeTypeChanged {
    after element uml::Type replaced at uml::Property[type]
    call changeJavaAttributeType(affectedEObject, newValue)
}

routine changeJavaAttributeType(uml::Property uAttr, uml::Type uType) {
    match {
        val jAttr = retrieve java::Field corresponding to uAttr
        val customType = retrieve optional java::Class corresponding to uType
    }
    action {
        update jAttr {
            jAttr.typeReference = createTypeReference(uType, customType);
        }
    }
}

reaction UmlLowerMultiplicityChanged {
    after attribute replaced at uml::LiteralInteger[value]
    call {
        handleMultiplicityForJavaAttribute(affectedEObject.owner as org.eclipse.uml2.uml.Property)
    }
}

reaction UmlUpperMultiplicityChanged {
    after attribute replaced at uml::LiteralUnlimitedNatural[value]
    call handleMultiplicityForJavaAttribute(affectedEObject.owner as org.eclipse.uml2.uml.Property)
}

routine handleMultiplicityForJavaAttribute(uml::Property uAttribute) {
    match {
        val jAttribute = retrieve java::Field corresponding to uAttribute
        val jType = retrieve java::Class corresponding to uAttribute.type
    }
    action {
        update jAttribute {
            if (uAttribute.lower == 0) {
                if (uAttribute.upper == 1) {
                    jAttribute.typeReference = createTypeReference(uAttribute.type, jType)
                } else if (uAttribute.upper == LiteralUnlimitedNatural.UNLIMITED) {
                    jAttribute.typeReference = createCollectiontypeReference(letUserSelectCollectionTypeName(userInteracting), jType)
                } else if (uAttribute.upper > 1) {
                    jAttribute.typeReference = createCollectiontypeReference(letUserSelectCollectionTypeName(userInteracting), jType)
                }
            } else if (uAttribute.lower == 1) {
                if (uAttribute.upper == 1) {
                    jAttribute.typeReference = createTypeReference(uAttribute.type, jType)
                }
            }
        }
        call {
            if (uAttribute.lower == 1 && uAttribute.upper == 1) {
                createJavaConstructor(jAttribute)
                createJavaGetter(jAttribute)
                createJavaSetterWithNullCheck(jAttribute)
            }
        }
    }
}

routine createJavaConstructor(java::Field jAttribute) {
    action {
        call {
            createNewForFieldInConstructor(jAttribute)
        }
    }
}

routine createJavaGetter(java::Field jAttribute) {
    action {
        call {
            if (!javaGetterForAttributeExists(jAttribute)) {
                createGetterForAttribute(jAttribute)
            }
        }
    }
}

routine createJavaSetterWithNullCheck(java::Field jAttribute) {
    action {
        call {
            if (!javaSetterForAttributeExists(jAttribute)) {
                createSetterForAttributeWithNullCheck(jAttribute)
            }
        }
    }
}
