import org.apache.log4j.PropertyConfigurator
import org.eclipse.uml2.uml.Class
import org.eclipse.uml2.uml.EnumerationLiteral
import org.eclipse.uml2.uml.Interface
import org.eclipse.uml2.uml.ParameterDirectionKind
import org.eclipse.uml2.uml.PrimitiveType
import org.emftext.language.java.classifiers.Enumeration
import org.emftext.language.java.types.NamespaceClassifierReference
import org.emftext.language.java.types.TypesFactory

import static tools.vitruv.applications.umljava.uml2java.UmlToJavaHelper.*
import static tools.vitruv.applications.umljava.util.JavaUtil.*
import static tools.vitruv.domains.java.util.JavaPersistenceHelper.*
import static tools.vitruv.applications.umljava.util.UmlUtil.*
import org.emftext.language.java.classifiers.ConcreteClassifier
import java.lang.reflect.Modifier
import org.emftext.language.java.modifiers.ModifiersFactory
import org.eclipse.uml2.uml.VisibilityKind
import org.eclipse.uml2.uml.UMLFactory

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml
import "http://www.emftext.org/java" as java

reactions: UmlToJava
in reaction to changes in uml
execute actions in java


reaction UmlClassCreated {
    after element uml::Class created and inserted in uml::Package[packagedElement]
    call createJavaClass(newValue)

}

routine createJavaClass(uml::Classifier umlClassifier) {
    action {
        val javaClassifier = create java::Class and initialize {
        	javaClassifier.name = umlClassifier.name;
        }
        add correspondence between umlClassifier and javaClassifier
        call { 
        	createJavaCompilationUnit ( umlClassifier , javaClassifier , umlClassifier . namespace )
        }
    }
}

routine createJavaCompilationUnit(uml::Classifier umlClassifier, java::ConcreteClassifier jClassifier, uml::Namespace uNamespace) {
	action {
		val javaCompilationUnit = create java::CompilationUnit and initialize {
			if (!(uNamespace instanceof org.eclipse.uml2.uml.Model)) {
				javaCompilationUnit.namespaces += getUmlNamespaceAsStringList(uNamespace)
			}
            javaCompilationUnit.name = jClassifier.name;
            javaCompilationUnit.classifiers += jClassifier;
            persistProjectRelative(umlClassifier, javaCompilationUnit, buildJavaFilePath(javaCompilationUnit));
        }
        add correspondence between umlClassifier and javaCompilationUnit
	}
}

reaction UmlPackageCreated {
	after element uml::Package created and inserted in uml::Package[packagedElement]
	call createJavaPackage(newValue)
}

routine createJavaPackage(uml::Package uPackage) {
	action {
		val jPackage = create java::Package and initialize {
			if (uPackage.namespace !== null) {
				jPackage.namespaces += getUmlParentNamespaceAsStringList(uPackage)
			}
		    jPackage.name = uPackage.name
		    persistProjectRelative(uPackage, jPackage, buildJavaFilePath(jPackage))
		}
		add correspondence between jPackage and uPackage
		call {
			for (subPackage : uPackage.packagedElements.filter(org.eclipse.uml2.uml.Package)) {
				createJavaPackage(subPackage)
			}
			for (containedClassifier : uPackage.packagedElements.filter(org.eclipse.uml2.uml.Classifier)) {
				changePackageOfJavaCompilationUnit(uPackage, containedClassifier)
			}
		}
	}
}

reaction UmlPackageRenamed {
	after attribute replaced at uml::Package[name]
	with !(affectedEObject instanceof org.eclipse.uml2.uml.Model)
	call renameJavaPackageAndClassifier(affectedEObject)
}

routine renameJavaPackageAndClassifier(uml::Package uPackage) {
	match {
		val jPackage = retrieve java::Package corresponding to uPackage
	}
	action {
		call {
			renameJavaPackage(uPackage)
			for (subPackage : uPackage.packagedElements.filter(org.eclipse.uml2.uml.Package)) {
				renameJavaPackageAndClassifier(subPackage)
			}
			for (containedClassifier : uPackage.packagedElements.filter(org.eclipse.uml2.uml.Classifier)) {
				changePackageOfJavaCompilationUnit(uPackage, containedClassifier)
			}
		}
	}
}

routine renameJavaPackage(uml::Package uPackage) {
	match {
		val jPackage = retrieve java::Package corresponding to uPackage
	}
	action {
		update jPackage {
			jPackage.namespaces.clear
			jPackage.namespaces += getUmlParentNamespaceAsStringList(uPackage)
			jPackage.name = uPackage.name
		    persistProjectRelative(uPackage, jPackage, buildJavaFilePath(jPackage))
		}
	}
}

reaction UmlClassifierPackageChanged {
	after element uml::Classifier inserted in uml::Package[packagedElement]
	with !(affectedEObject instanceof org.eclipse.uml2.uml.Model)
	call changePackageOfJavaCompilationUnit(affectedEObject, newValue)
}

routine changePackageOfJavaCompilationUnit(uml::Package uPackage, uml::Classifier uClassifier) {
	match {
		val jCompUnit = retrieve java::CompilationUnit corresponding to uClassifier
		val jPackage = retrieve java::Package corresponding to uPackage
	}
	action {
		update jPackage {
			jPackage.compilationUnits += jCompUnit
		}
		update jCompUnit {
			jCompUnit.namespaces.clear
			jCompUnit.namespaces += getUmlNamespaceAsStringList(uPackage)
			persistProjectRelative(uClassifier, jCompUnit, buildJavaFilePath(jCompUnit))
		}
	}
}

reaction UmlPackageDeleted {
	after element uml::Package deleted and removed from uml::Package[packagedElement]
	call deleteJavaPackage(oldValue)
}

routine deleteJavaPackage(uml::Package uPackage) {
	match {
		val jPackage = retrieve java::Package corresponding to uPackage
	}
	action {
		delete jPackage
	}
}

reaction UmlClassifierRenamed {
    after attribute replaced at uml::Classifier[name]
    call renameJavaClassifier(affectedEObject)
}

routine renameJavaClassifier(uml::Classifier umlClassifier) {
    match {
        val javaClassifier = retrieve java::ConcreteClassifier corresponding to umlClassifier
        val javaCompilationUnit = retrieve java::CompilationUnit corresponding to umlClassifier
    }
    action {
        update javaClassifier {
            javaClassifier.name = umlClassifier.name;
        }
        update javaCompilationUnit {
            javaCompilationUnit.name = umlClassifier.name;
            persistProjectRelative(umlClassifier, javaCompilationUnit, buildJavaFilePath(javaCompilationUnit));

        }
    }
}

reaction UmlClassifierDeleted {
    after element uml::Classifier deleted and removed from uml::Model[packagedElement]
    call deleteJavaClass(oldValue)
}

routine deleteJavaClass(uml::Classifier umlClassifer) {
    match {
        val javaClassifier = retrieve java::ConcreteClassifier corresponding to umlClassifer
        val javaCompilationUnit = retrieve java::CompilationUnit corresponding to umlClassifer
    }
    action {
        delete javaClassifier
        delete javaCompilationUnit
    }
}

reaction UmlClassMadeFinal {
    after attribute replaced at uml::Class[isFinalSpecialization] 
    call setJavaClassFinal(affectedEObject)
}

routine setJavaClassFinal(uml::Class umlClass) {
    match {
        val jClass = retrieve java::Class corresponding to umlClass
    }
    action {
        val finalMod = create java::Final
        update jClass {
            setJavaModifier(jClass, finalMod, umlClass.isFinalSpecialization);
        }
    }
}

reaction UmlClassMadeAbstract {
    after attribute replaced at uml::Class[isAbstract]
    call setJavaClassAbstract(affectedEObject)
}

routine setJavaClassAbstract(uml::Class umlClass) {
    match {
        val jClass = retrieve java::Class corresponding to umlClass
    }
    action {
        val abstr = create java::Abstract
        update jClass {
            setJavaModifier(jClass, abstr, umlClass.abstract);
        }
    }
}

reaction UmlElementVisibilityChanged {
    after attribute replaced at uml::NamedElement[visibility]
    call changeJavaElementVisibility(affectedEObject)
}

routine changeJavaElementVisibility(uml::NamedElement uElem) {
    match {
        val jElem = retrieve java::AnnotableAndModifiable corresponding to uElem
    }
    action {
        update jElem {
            setJavaVisibility(jElem, uElem.visibility);
        }
    }
}

reaction UmlSuperClassChanged {
    after element uml::Generalization inserted in uml::Class[generalization]//TODO Warnung, wenn schon gesetzt
    call {
    	changeJavaSuperClass(newValue.general as Class, affectedEObject)
    }
}

routine changeJavaSuperClass(uml::Class superUMLClass, uml::Class uClass) {
    match {
        val jClass = retrieve java::Class corresponding to uClass
        val superJavaClass = retrieve java::Class corresponding to superUMLClass
    }
    action {
        update jClass {
            jClass.extends = createTypeReference(null, superJavaClass);
        }
    }
}

reaction UmlSuperClassDeleted {
    after element uml::Generalization removed from uml::Class[generalization]
    call deleteJavaSuperClass(affectedEObject)
}

routine deleteJavaSuperClass(uml::Class uClass) {
    match {
        val jClass = retrieve java::Class corresponding to uClass
    }
    action {
        update jClass {
            jClass.extends = null;
        }
    }
}

reaction UmlEnumCreated {
	after element uml::Enumeration created and inserted in uml::Package[packagedElement]
	call createJavaEnum(newValue)
}

routine createJavaEnum(uml::Enumeration uEnum) {
	action {
		val jEnum = create java::Enumeration and initialize {
			jEnum.name = uEnum.name
			for (EnumerationLiteral enumLit : uEnum.ownedLiterals) {//TODO Hoffentlich sparen
				jEnum.constants += createJavaEnumConstant(enumLit)
			}
		}
		add correspondence between uEnum and jEnum
		call {
			createJavaCompilationUnit(uEnum, jEnum, uEnum.namespace)
		}
	}
}

reaction UmlEnumLiteralCreated {
	after element uml::EnumerationLiteral created and inserted in uml::Enumeration[ownedLiteral]
	call createJavaEnumConstant(newValue, affectedEObject)
}

routine createJavaEnumConstant(uml::EnumerationLiteral uLiteral, uml::Enumeration uEnum) {
	match {
		val jEnum = retrieve java::Enumeration corresponding to uEnum
	}
	action {
		val jConstant = create java::EnumConstant and initialize {
			if (uLiteral.name == null) {
				jConstant.name = "DefaultEnumConstantName"
			} else {
				jConstant.name = uLiteral.name
			}
		}
		add correspondence between jConstant and uLiteral
		update jEnum {
			jEnum.constants += jConstant
		}
	}
}

reaction UmlEnumLiteralDeleted {
	after element uml::EnumerationLiteral deleted and removed from uml::Enumeration[ownedLiteral]
	call deleteJavaEnumConstant(oldValue)
}

routine deleteJavaEnumConstant(uml::EnumerationLiteral uLiteral) {
	match {
		val jConst = retrieve java::EnumConstant corresponding to uLiteral
	}
	action {
		delete jConst
	}
}

reaction UmlNamedElementRenamed{
	after attribute replaced at uml::NamedElement[name] 
	with !(affectedEObject instanceof org.eclipse.uml2.uml.Classifier)
	&& !(affectedEObject instanceof org.eclipse.uml2.uml.Package)
	call renameJavaNamedElement(affectedEObject, newValue)
}

routine renameJavaNamedElement(uml::NamedElement uElem, String name) {
	match {
		val jElem = retrieve java::NamedElement corresponding to uElem
	}
	action {
		update jElem {
			jElem.name = name
		}
	}
}

reaction UmlDataTypeCreated {
	after element uml::DataType created and inserted in uml::Model[packagedElement] with !(newValue instanceof PrimitiveType)
	&& !(newValue instanceof Enumeration) 
	call createJavaClass(newValue)
}

reaction UmlCollectionDataTypeCreated {
	after element uml::Property created and inserted in uml::DataType[ownedAttribute]
	call createJavaCollectionClass(affectedEObject, newValue)
}

routine createJavaCollectionClass(uml::DataType dType, uml::Property innerType) {
	match {
		val jCollectionClass = retrieve java::Class corresponding to dType
		val jInnerType = retrieve optional java::Class corresponding to innerType.type
	}
	action {
		update jCollectionClass {
			if (jInnerType != null) {
				//createTypeReference()
			} else if (innerType.type instanceof PrimitiveType) {
				//TODO Wrapper für Primitive Typen
		        //--> org.emftext.language.java.references.PrimitiveTypeReference?
			} else {
				//verschachtelter DataType
			}
		}
	}
}

reaction UmlInterfaceImplementerChanged {
	after element uml::Class replaced at uml::InterfaceRealization[owner]
	call {
		deleteJavaImplementedInterface(affectedEObject.contract, oldValue)
		changeJavaImplementedInterface(affectedEObject.contract, null, newValue)
	}
}

reaction UmlImplementedInterfaceChanged {
    after element uml::Interface replaced at uml::InterfaceRealization[contract]
    call changeJavaImplementedInterface(newValue, oldValue, affectedEObject.eContainer as Class)
}

routine changeJavaImplementedInterface(uml::Interface uI, uml::Interface oldInterface, uml::Class uClass) {
    match {
        val jClass = retrieve java::Class corresponding to uClass
        val jI = retrieve java::Interface corresponding to uI
    }
    action {
    	call {
            if (oldInterface !== null) {
        		deleteJavaImplementedInterface(oldInterface, uClass)
        	}
        }
        update jClass {
            jClass.implements += createTypeReference(null, jI);
        }
    }
}

reaction UmlImplementedInterfaceDeleted {
    after element uml::InterfaceRealization removed from uml::Class[interfaceRealization]
    call deleteJavaImplementedInterface(oldValue.suppliers.head as Interface , affectedEObject)
}

routine deleteJavaImplementedInterface(uml::Interface uI, uml::Class uClass) {
    match {
        val jClass = retrieve java::Class corresponding to uClass
        val jI = retrieve java::Interface corresponding to uI
    }
    action {
        update jClass {
            removeClassifierFromIterator(jClass.implements.iterator, jI) 
        }
    }
}



reaction UmlInterfaceCreated {
    after element uml::Interface created and inserted in uml::Package[packagedElement]
    call createJavaInterface(newValue)
}

routine createJavaInterface(uml::Interface umlInterface) {
    action {
        val javaInterface = create java::Interface and initialize {
            javaInterface.name = umlInterface.name;
        }
        add correspondence between umlInterface and javaInterface
        call {
			createJavaCompilationUnit(umlInterface, javaInterface, umlInterface.namespace)
		}
    }
}

 
reaction UmlSuperInterfaceChanged {
    after element uml::Generalization inserted in uml::Interface[generalization]
    call changeJavaSuperInterface(newValue.general as Interface, affectedEObject)
}

routine changeJavaSuperInterface(uml::Interface superUMLInterface, uml::Interface uI) {
    match {
        val jI = retrieve java::Interface corresponding to uI
        val superJavaInterface = retrieve java::Interface corresponding to superUMLInterface
    }
    action {
        update jI {
            jI.extends += createTypeReference(null, superJavaInterface)
        }
    }
}

reaction UmlSuperInterfaceDeleted {
    after element uml::Generalization removed from uml::Interface[generalization]
    call deleteJavaSuperInterface(oldValue.general as Interface, affectedEObject)
}

routine deleteJavaSuperInterface(uml::Interface superUMLInterface, uml::Interface uI) {
    match {
        val jI = retrieve java::Interface corresponding to uI
        val javaSuperInterface = retrieve java::Interface corresponding to superUMLInterface
    }
    action {
        update jI {
            val iter = jI.extends.listIterator
            while (iter.hasNext) {
                val type = (iter.next as NamespaceClassifierReference).classifierReferences.head.target
                if (javaSuperInterface.name.equals(type.name)) {
                    iter.remove;
                }
            }
            //TODO Ersetzen durch removeClassifierFromIterator(jI.extends.iterator, javaSuperInterface)
        }
    }
}



reaction UmlAttributeCreated {
    after element uml::Property created and inserted in uml::Class[ownedAttribute]
    call {
        createJavaAttribute(affectedEObject, newValue)
    }
}

routine createJavaAttribute(uml::Class umlClass, uml::Property umlAttribute) {
    match {
        val javaClass = retrieve java::Class corresponding to umlClass
        val customTypeClass = retrieve optional java::Class corresponding to umlAttribute.type
    }
    action {
        val javaAttribute = create java::Field and initialize {
            if (umlAttribute.name == null) {
                javaAttribute.name = "DefaultAttributeName"
            } else {
                javaAttribute.name = umlAttribute.name;
            }
            if (umlAttribute.visibility != null && umlAttribute.visibility != VisibilityKind.PACKAGE_LITERAL) {
            	setJavaVisibility(javaAttribute, umlAttribute.visibility)
            }
            if (umlAttribute.static) {
            	javaAttribute.addModifier(ModifiersFactory.eINSTANCE.createStatic)
            }
            if (umlAttribute.isReadOnly) {
            	javaAttribute.addModifier(ModifiersFactory.eINSTANCE.createFinal)
            }
            if (umlAttribute.type != null) {
            	javaAttribute.typeReference = createTypeReference(umlAttribute.type, customTypeClass);
            }
        }
        update javaClass {
            handleMultiplicityAndAddToClass(umlAttribute, javaAttribute, javaClass);
        }
        add correspondence between umlAttribute and javaAttribute
    }
}

reaction UmlAttributeRenamed {
    after attribute replaced at uml::Property[name]
    call renameJavaAttribute(affectedEObject)
}

//TypedElement kann Attribut oder Parameter sein
routine renameJavaAttribute(uml::Property umlAttr) {
    match {
        val jAttr = retrieve java::Field corresponding to umlAttr
    }
    action {
        update jAttr {
            jAttr.name = umlAttr.name
        }
    }
}

reaction UmlAttributeDeleted {
    after element uml::Property deleted and removed from uml::Class[ownedAttribute]
    call deleteJavaAttribute(oldValue)
}

routine deleteJavaAttribute(uml::Property umlAttr) {
    match {
        val jAttr = retrieve java::Field corresponding to umlAttr
    }
    action {
        delete jAttr
    }
}

reaction UmlMethodCreated {
    after element uml::Operation created and inserted in uml::Class[ownedOperation]
    call {
        createJavaMethod(affectedEObject, newValue)       
    }
}

routine createJavaMethod(uml::Class uClass, uml::Operation umlOp) {
    match {
        
        val javaClass = retrieve java::Class corresponding to uClass
        val customTypeClass = retrieve optional java::Class corresponding to umlOp.type
    }
    action {
        val javaMethod = create java::ClassMethod and initialize {
            if (umlOp.name == null) {
                javaMethod.name = "DefaultMethodName"
            } else {
                javaMethod.name = umlOp.name;
            }
            if (umlOp.visibility != null && umlOp.visibility != VisibilityKind.PACKAGE_LITERAL) {
            	setJavaVisibility(javaMethod, umlOp.visibility)
            }
            if (umlOp.static) {
            	javaMethod.addModifier(ModifiersFactory.eINSTANCE.createStatic)
            }
            if (umlOp.abstract) {
            	javaMethod.addModifier(ModifiersFactory.eINSTANCE.createAbstract)
            }
            javaMethod.typeReference = createTypeReference(umlOp.type, customTypeClass)
        }
        update javaClass {
            javaClass.members += javaMethod;
            logger.info("Correspondence Added: " + umlOp + ", " + javaMethod)
        }
        add correspondence between umlOp and javaMethod
    }
}

reaction UmlMethodRenamed {
    after attribute replaced at uml::Operation[name]
    call renameJavaMethod(affectedEObject)
}
//Geht für ClassMethod und InterfaceMethod
routine renameJavaMethod(uml::Operation umlOp) {
    match {
        val jMeth = retrieve java::Method corresponding to umlOp
    }
    action {
        update jMeth {
            jMeth.name = umlOp.name
        }
    }
}

reaction UmlClassMethodDeleted {
    after element uml::Operation deleted and removed from uml::Class[ownedOperation]
    call deleteJavaMethod(oldValue)
}

reaction UmlInterfaceMethodDeleted {
    after element uml::Operation deleted and removed from uml::Interface[ownedOperation]
    call deleteJavaMethod(oldValue)
}

//Geht für ClassMethod und InterfaceMethod
routine deleteJavaMethod(uml::Operation umlOp) {
    match {
        val jMeth = retrieve java::Method corresponding to umlOp
    }
    action {
        delete jMeth
    }
}

reaction UmlParameterCreated {
    after element uml::Parameter created and inserted in uml::Operation[ownedParameter]
    call createJavaParameter(affectedEObject, newValue)

}

routine createJavaParameter(uml::Operation uMeth, uml::Parameter umlParam) {
    match {
        val javaMethod = retrieve java::Method corresponding to uMeth
        val customType = retrieve optional java::Class corresponding to umlParam.type
    }
    action {
        val javaParam = create java::OrdinaryParameter and initialize {
            if (umlParam.name != null) {
                javaParam.name = umlParam.name;
            } else {
                javaParam.name = "Defaultname";
            }
            javaParam.typeReference = createTypeReference(umlParam.type, customType)
        }
        add correspondence between javaParam and umlParam
        update javaMethod {
            javaMethod.parameters += javaParam;
        }
    }
}

reaction UmlParameterRenamed {
    after attribute replaced at uml::Parameter[name]
    call renameJavaParameter(affectedEObject)
}

routine renameJavaParameter(uml::Parameter uParam) {
    match {
        val jParam = retrieve java::OrdinaryParameter corresponding to uParam
    }
    action {
        update jParam {
            jParam.name = uParam.name;
        }
    }
}

reaction UmlParameterDeleted {
    after element uml::Parameter deleted and removed from uml::Operation[ownedParameter]
    call deleteJavaParameter(oldValue)
}

routine deleteJavaParameter(uml::Parameter uParam) {
    match {
        val jParam = retrieve java::OrdinaryParameter corresponding to uParam
    }
    action {
        delete jParam
    }
}

//Bei Änderung eines Parameters oder ReturnTypes
reaction UmlParameterTypeChanged {
    after element uml::Type replaced at uml::Parameter[type]
    call  changeJavaParameterType(affectedEObject, newValue)
}

routine changeJavaParameterType(uml::Parameter uParam, uml::Type uType) {
    match {
        val jParam = retrieve optional java::OrdinaryParameter corresponding to uParam
        val jMeth = retrieve java::Method corresponding to uParam.operation
        val customClass = retrieve optional java::Class corresponding to uType
    }
    action {
        update jParam {
            val jType = createTypeReference(uType, customClass);
            if (uParam.direction.equals(ParameterDirectionKind.RETURN_LITERAL)) {
                jMeth.typeReference = jType;
                if (jParam != null) {
                    //call deleteJavaParameter(jParam)
                }
            } else {
                jParam.typeReference = jType;
            }
        }
    }
}

reaction UmlMethodReturnTypeCreated {
    after attribute replaced at uml::Parameter[direction] with newValue == ParameterDirectionKind.RETURN_LITERAL
    call setJavaMethodReturnType(affectedEObject, 0)
}

reaction UmlMethodReturnTypeRemoved {
    after attribute replaced at uml::Parameter[direction] with oldValue == ParameterDirectionKind.RETURN_LITERAL
    && newValue != ParameterDirectionKind.RETURN_LITERAL
    call setJavaMethodReturnType(affectedEObject, 1)
}

//1 == true
routine setJavaMethodReturnType(uml::Parameter uParam, Integer changedToVoid) {//TODO plain
    match {
        val javaMethod = retrieve java::Method corresponding to uParam.operation
        val jParam = retrieve java::OrdinaryParameter corresponding to uParam
        val returnType = retrieve java::Class corresponding to uParam.type
        
    }
    action {
        update javaMethod {
            if (changedToVoid == 1) {
                 javaMethod.typeReference = TypesFactory.eINSTANCE.createVoid
            } else {
                javaMethod.typeReference = createTypeReference(uParam.type, returnType);
            }
        }
    }
}

reaction UmlAttributeTypeChanged {
    after element uml::Type replaced at uml::Property[type]
    call changeJavaAttributeType(affectedEObject, newValue)
}

routine changeJavaAttributeType(uml::Property uAttr, uml::Type uType) {
    match {
        val jAttr = retrieve java::Field corresponding to uAttr
        val customType = retrieve optional java::Class corresponding to uType
    }
    action {
        update jAttr {
            jAttr.typeReference = createTypeReference(uType, customType);
        }
    }
}
reaction UmlAttributeMadeFinal {
    after attribute replaced at uml::Property[isReadOnly]
    call setJavaAttributeFinal(affectedEObject) 
}

routine setJavaAttributeFinal(uml::Property umlAttr) {
    match {
        val jAttr = retrieve java::Field corresponding to umlAttr
    }
    action {
        val finalMod = create java::Final
        update jAttr {
            setJavaModifier(jAttr, finalMod, umlAttr.isReadOnly);
        }
    }
}

//Feature definiert isStatic  -> kann u.a.Attribut oder Methode sein
reaction UmlFeatureMadeStatic {
    after attribute replaced at uml::Feature[isStatic]
    call setStatic(affectedEObject)
}

routine setStatic(uml::Feature uFeat) {
    match {
        //AnnotableAndModifiable kann u.a. Methode oder Attribut sein
        val jMod = retrieve java::AnnotableAndModifiable corresponding to uFeat
    }
    action {
        val staticMod = create java::Static
        update jMod {
            setJavaModifier(jMod, staticMod, uFeat.isStatic);
        }
    }
}

reaction UmlMethodMadeAbstract {
    after attribute replaced at uml::Operation[isAbstract] 
    call setJavaMethodAbstract(affectedEObject)
}

routine setJavaMethodAbstract(uml::Operation umlOp) {
    match {
        val javaClass = retrieve java::Class corresponding to umlOp.class_
        val javaMethod = retrieve java::ClassMethod corresponding to umlOp
    }
    action {
        val abstr = create java::Abstract
        update javaMethod {
            setJavaModifier(javaMethod, abstr, umlOp.abstract);
        }
    }    
}

reaction UmlInterfaceMethodCreated {
    after element uml::Operation created and inserted in uml::Interface[ownedOperation]
    call createJavaInterfaceMethod(newValue)
}

routine createJavaInterfaceMethod(uml::Operation umlOp) {
    match {
        val jInterface = retrieve java::Interface corresponding to umlOp.interface
        val customClassType = retrieve optional java::Class corresponding to umlOp.type
    }
    action {
        val javaMethod = create java::InterfaceMethod and initialize {
            if (umlOp.name == null) {
                javaMethod.name = "DefaultInterfaceMethodName";
            } else {
                javaMethod.name = umlOp.name;
            }
            javaMethod.typeReference = createTypeReference(umlOp.type, customClassType);
        }
        add correspondence between umlOp and javaMethod
        update jInterface {
            jInterface.members += javaMethod;
        }
    }
}



reaction Log { //TODO In Tests definieren
    after any change
    call {
        PropertyConfigurator.configure("log4j.properties")
    }
}