import static extension tools.vitruv.domains.java.util.JavaPersistenceHelper.*;
import static extension tools.vitruv.applications.umljava.uml2java.UmlToJavaHelper.*;
import org.apache.log4j.PropertyConfigurator
import org.emftext.language.java.types.TypesFactory
import org.emftext.language.java.parameters.ParametersFactory
import mir.routines.umlToJava.ChangeJavaMethodVisibilityRoutine

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml
import "http://www.emftext.org/java" as java

reactions: UmlToJava
in reaction to changes in uml
execute actions in java



reaction CreatedUmlClass {
    after element uml::Class created and inserted in uml::Model[packagedElement]
    call createJavaClass(newValue)
}

routine createJavaClass(uml::Class umlClass) {
    action {
        val javaClass = create java::Class and initialize {
            javaClass.name = umlClass.name;
        }
        add correspondence between umlClass and javaClass
        val javaCompilationUnit = create java::CompilationUnit and initialize {
            logger.info("Create JClass Routine")
            javaCompilationUnit.name = umlClass.name;
            //javaCompilationUnit.namespaces += "testPackage" // FIXME Only for testing purposes
            javaCompilationUnit.classifiers += javaClass;
            persistProjectRelative(umlClass, javaCompilationUnit, buildJavaFilePath(javaCompilationUnit));
        }
        add correspondence between umlClass and javaCompilationUnit
    }
}

reaction RenameUmlClass {
    after attribute replaced at uml::Class[name]
    call renameJavaClass(affectedEObject)
}

routine renameJavaClass(uml::Class umlClass) {
    match {
        val javaClass = retrieve java::Class corresponding to umlClass
        val javaCompilationUnit = retrieve java::CompilationUnit corresponding to umlClass
    }
    action {
        update javaClass {
            javaClass.name = umlClass.name;
        }
        update umlClass {
            javaCompilationUnit.name = umlClass.name;
            persistProjectRelative(umlClass, javaCompilationUnit, buildJavaFilePath(javaCompilationUnit));
        }
    }
}

reaction DeletedUmlClass {
    after element uml::Class deleted and removed from uml::Model[packagedElement]
    call deleteJavaClass(oldValue)
}

routine deleteJavaClass(uml::Class umlClass) {
    match {
        val javaClass = retrieve java::Class corresponding to umlClass
        val javaCompilationUnit = retrieve java::CompilationUnit corresponding to umlClass
    }
    action {
        delete javaClass
        delete javaCompilationUnit

        //TODO: Schauen, ob Attribute Methoden automatisch mitgelöscht werden

    }
}

reaction ChangedUmlClassFinal {
    after attribute replaced at uml::Class[isFinalSpecialization] 
    call changeJavaClassFinal(affectedEObject)
}
routine changeJavaClassFinal(uml::Class umlClass) {
    match {
        val jClass = retrieve java::Class corresponding to umlClass
    }
    action {
        val finalMod = create java::Final
        update jClass {
            if (umlClass.isFinalSpecialization) {
                jClass.addModifier(finalMod)
            } else {
                jClass.removeModifier(finalMod.class)
            }
        }
    }
}

reaction ChangedAbstractUmlClass {
    after attribute replaced at uml::Class[isAbstract]
    call changeAbstractJavaClass(affectedEObject)
}

routine changeAbstractJavaClass(uml::Class umlClass) {
    match {
        val javaClass = retrieve java::Class corresponding to umlClass
    }
    action {
        val abstr = create java::Abstract
        update javaClass {
            if (umlClass.isAbstract) {
                javaClass.addModifier(abstr)
            } else {
                javaClass.removeModifier(abstr.class)
                
            }
            
        }
    }
}

reaction ChangedUmlClassVisibility {
    after attribute replaced at uml::Class[visibility]
    call changeJavaClassVisibility(affectedEObject)
}

routine changeJavaClassVisibility(uml::Class uClass) {
    match {
        val jClass = retrieve java::Class corresponding to uClass
    }
    action {
        update jClass {
            removeJavaVisibilityModifiers(jClass)
            jClass.addModifier(getJavaVisibility(uClass.visibility))
        }
    }
}

reaction CreatedUmlInterface {
    after element uml::Interface created and inserted in uml::Model[packagedElement]
    call createJavaInterface(newValue)
}

routine createJavaInterface(uml::Interface umlInterface) {
    action {
        val javaInterface = create java::Interface and initialize {
            javaInterface.name = umlInterface.name;
        }
        add correspondence between umlInterface and javaInterface
        val javaCompilationUnit = create java::CompilationUnit and initialize {
            javaCompilationUnit.name = umlInterface.name;
            javaCompilationUnit.classifiers += javaInterface;
            persistProjectRelative(umlInterface, javaCompilationUnit, buildJavaFilePath(javaCompilationUnit));
        }
        add correspondence between umlInterface and javaCompilationUnit
    }
}

reaction RenamedUmlInterface {
    after attribute replaced at uml::Interface[name]
    call renameJavaInterface(affectedEObject)
}

routine renameJavaInterface(uml::Interface umlInterface) {
    match {
        val jInterface = retrieve java::Interface corresponding to umlInterface
        val jCompUnit = retrieve java::CompilationUnit corresponding to umlInterface
    }
    action {
        update jInterface {
            jInterface.name = umlInterface.name;
        }
        
        update jCompUnit {
            jCompUnit.name = umlInterface.name;
            persistProjectRelative(umlInterface, jCompUnit, buildJavaFilePath(jCompUnit));
        }
    }
}

reaction DeletedUmlInterface {
    after element uml::Interface deleted and removed from uml::Model[packagedElement]
    call deleteJavaInterface(oldValue)
}


routine deleteJavaInterface(uml::Interface umlInterface) {
    match {
         val jInterface = retrieve java::Interface corresponding to umlInterface
         val jCompUnit = retrieve java::CompilationUnit corresponding to umlInterface
    }
    action {
        delete jInterface
        delete jCompUnit
    }
}
/* 
reaction ChangedSuperInterface {
    after attribute replaced at uml::Interface[]
}

*/

reaction CreatedUmlAttribute {
    after element uml::Property created and inserted in uml::Class[ownedAttribute]
    call {
        logger.info("------------ CreateAttr Reaction ---------------------")
        createJavaAttribute(affectedEObject, newValue)
    }
}



routine createJavaAttribute(uml::Class umlClass, uml::Property umlAttribute) {
    match {
        val javaClass = retrieve java::Class corresponding to umlClass
        
        val customTypeClass = retrieve optional java::Class corresponding to umlAttribute.type
    }
    action {
        val javaAttribute = create java::Field and initialize {
            logger.info("------------- CreateAttr Routine -------------")
            if (umlAttribute.name == null) {
                javaAttribute.name = "DefaultAttributeName"
            } else {
                javaAttribute.name = umlAttribute.name;
            }
            javaAttribute.typeReference = createTypeReference(umlAttribute.datatype, customTypeClass);    
        }
        
       
        update javaClass {
          javaClass.members += javaAttribute;
        }
        add correspondence between umlAttribute and javaAttribute
    }
}


reaction RenamedUmlAttribute {
    after attribute replaced at uml::Property[name]
    call renameJavaAttribute(affectedEObject)
}

routine renameJavaAttribute(uml::Property umlAttr) {
    match {
        val jAttr = retrieve java::Field corresponding to umlAttr
    }
    action {
        update jAttr {
            jAttr.name = umlAttr.name
        }
    }
}

reaction DeletedUmlAttribute {
    after element uml::Property deleted and removed from uml::Class[ownedAttribute]
    call deleteJavaAttribute(oldValue)
}

routine deleteJavaAttribute(uml::Property umlAttr) {
    match {
        val jAttr = retrieve java::Field corresponding to umlAttr
    }
    action {
        //TODO: Schauen, ob in javaClass.members das Attribut korrekt entfernt wurde
        delete jAttr
    }
}

reaction CreatedUmlMethod {
    after element uml::Operation created and inserted in uml::Class[ownedOperation]
    call {
        logger.info("Create Java Method Reaction")
        createJavaMethod(affectedEObject, newValue)
        
        }
}

routine createJavaMethod(uml::Class uClass, uml::Operation umlOp) {
    match {
        
        val javaClass = retrieve java::Class corresponding to uClass
        val customTypeClass = retrieve optional java::Class corresponding to umlOp.type
    }
    action {
      
        val javaMethod = create java::ClassMethod and initialize {
            logger.info("CreateJavaMethod Routine")
            if (umlOp.name == null) {
                javaMethod.name = "DefaultMethodName"
            } else {
                javaMethod.name = umlOp.name;
            }
            javaMethod.typeReference = createTypeReference(umlOp.type, customTypeClass)
        }
        
        update javaClass {
            javaClass.members += javaMethod;
        }
        add correspondence between umlOp and javaMethod
    }
}


reaction RenamedUmlMethod {
    after attribute replaced at uml::Operation[name]
    call renameJavaMethod(affectedEObject)
}
//Geht für ClassMethod und InterfaceMethod?
routine renameJavaMethod(uml::Operation umlOp) {
    match {
        val jMeth = retrieve java::Method corresponding to umlOp
    }
    action {
        update jMeth {
            jMeth.name = umlOp.name
        }
    }
}

reaction DeletedUmlClassMethod {
    after element uml::Operation deleted and removed from uml::Class[ownedOperation]
    call deleteJavaMethod(oldValue)
}

reaction DeletedUmlInterfaceMethod {
    after element uml::Operation deleted and removed from uml::Interface[ownedOperation]
    call deleteJavaMethod(oldValue)
}

//Geht für ClassMethod und InterfaceMethod?
routine deleteJavaMethod(uml::Operation umlOp) {
    match {
        val jMeth = retrieve java::Method corresponding to umlOp
    }
    action {
        delete jMeth
    }
}


reaction CreatedUmlParameter {
    after element uml::Parameter created and inserted in uml::Operation[ownedParameter]
    call createJavaParameter(newValue)
}
//Sollte für ClassMethod und InterfaceMethod gehen
routine createJavaParameter(uml::Parameter umlParam) {
    match {
        val javaMethod = retrieve java::Method corresponding to umlParam.operation
        val customType = retrieve java::Class corresponding to umlParam.type
    }
    action {
        val javaParam = create java::OrdinaryParameter and initialize {
            javaParam.name = umlParam.name;
            javaParam.typeReference = createTypeReference(umlParam.type, customType)
        }
        add correspondence between javaParam and umlParam
        update javaMethod {
            javaMethod.parameters += javaParam;
        }
    }
}

reaction ChangedUmlMethodReturnType {
    after element replaced at uml::Operation[type]
    call changeJavaMethodReturnType(affectedEObject)
}

//TODO Für ClassMethod & InterfaceMethod gleichzeitig anwendbar?
routine changeJavaMethodReturnType(uml::Operation umlOp) {
    match {
        val javaMethod = retrieve java::Method corresponding to umlOp
        val returnType = retrieve java::Class corresponding to umlOp.type
        
    }
    action {
        update javaMethod {
            javaMethod.typeReference = createTypeReference(umlOp.datatype, returnType)
        }
    }
}

//reaction ChangedUmlAttributeType {
//    after attribute replaced at uml::Property[]
    
//}
reaction ChangedUmlAttributeFinal {
    after attribute replaced at uml::Property[isReadOnly]
    call changeJavaAttributeFinal(affectedEObject) 
}

routine changeJavaAttributeFinal(uml::Property umlAttr) {
    match {
        val jAttr = retrieve java::Field corresponding to umlAttr
    }
    action {
        val finalMod = create java::Final
        update jAttr {
            if (umlAttr.isReadOnly) {
                jAttr.addModifier(finalMod)
            } else {
                jAttr.removeModifier(finalMod.class)
            }
        }
    }
}
 

//Feature definiert isStatic  -> kann u.a.Attribut oder Methode sein
reaction ChangedStaticFeature {
    after attribute replaced at uml::Feature[isStatic]
    call changeStatic(affectedEObject)
}

routine changeStatic(uml::Feature uFeat) {
    match {
        //AnnotableAndModifiable kann u.a. Methode oder Attribut sein
        val jMod = retrieve java::AnnotableAndModifiable corresponding to uFeat
    }
    action {
        val staticMod = create java::Static
        update jMod {
            if (uFeat.isStatic) {
                jMod.addModifier(staticMod)
            } else {
                jMod.removeModifier(staticMod.class)
            }
        }
    }
}
/* 
reaction ChangedStaticUmlMethod {
    after attribute replaced at uml::Operation[isStatic]
    call changeStaticJavaMethod(affectedEObject)
}

//TODO Statisch machen von Meth & Attr zusammenlegen?
routine changeStaticJavaMethod(uml::Operation umlOp) {
    match {
        val javaMethod = retrieve java::ClassMethod corresponding to umlOp
    }
    action {
        val staticMod = create java::Static
        update javaMethod {
            if (umlOp.isStatic) {
                javaMethod.addModifier(staticMod)
            } else {
                javaMethod.removeModifier(staticMod.class)
            }
        }
    }
}

reaction ChangedStaticUmlAttribute {
    after attribute replaced at uml::Property[isStatic]
    call changeStaticJavaAttribute(affectedEObject)
}

routine changeStaticJavaAttribute(uml::Property umlAttr) {
    match {
        val javaAttr = retrieve java::Field corresponding to umlAttr
    }
    action {
        val staticMod = create java::Static
        update javaAttr {
            if (umlAttr.isStatic) {
                javaAttr.addModifier(staticMod);
            } else {
                javaAttr.removeModifier(staticMod.class)
            }
        }
    }
}
*/
reaction ChangedAbstractUmlMethod {
    after attribute replaced at uml::Operation[isAbstract] 
    call changeAbstractJavaMethod(affectedEObject)
}

routine changeAbstractJavaMethod(uml::Operation umlOp) {
    match {
        val javaClass = retrieve java::Class corresponding to umlOp.class_
        val javaMethod = retrieve java::ClassMethod corresponding to umlOp
    }
    action {
        val abstr = create java::Abstract
        update javaMethod {
            if (umlOp.isAbstract) {
                javaMethod.addModifier(abstr)
                umlOp.class_.isAbstract = true;
                
            } else {
                javaMethod.removeModifier(abstr.class)
            }
            
        }
    }    
}


reaction ChangedUmlAttributeVisibility {
    after attribute replaced at uml::Property[visibility]
    call changeJavaAttributeVisibility(affectedEObject)
}

routine changeJavaAttributeVisibility(uml::Property umlAttr) {
    match {
        val javaAttr = retrieve java::Field corresponding to umlAttr
    }
    action {
        update javaAttr {
            removeJavaVisibilityModifiers(javaAttr)
            javaAttr.addModifier(getJavaVisibility(umlAttr.visibility))
        }
    }
}

reaction ChangedUmlMethodVisibility {
    after attribute replaced at uml::Operation[visibility]
    call changeJavaMethodVisibility(affectedEObject)
}

routine changeJavaMethodVisibility(uml::Operation umlOp) {
    match {
        val jMeth = retrieve java::ClassMethod corresponding to umlOp
    }
    action {
        update jMeth {
            removeJavaVisibilityModifiers(jMeth)
            jMeth.addModifier(getJavaVisibility(umlOp.visibility))
        }
    }
}




reaction CreatedUmlInterfaceMethod {
    after element uml::Operation created and inserted in uml::Interface[ownedOperation]
    call createJavaInterfaceMethod(newValue)
}

routine createJavaInterfaceMethod(uml::Operation umlOp) {
    match {
        val jInterface = retrieve java::Interface corresponding to umlOp.interface
        val customClassType = retrieve optional java::Class corresponding to umlOp.type
    }
    action {
        val javaMethod = create java::InterfaceMethod and initialize {
            if (umlOp.name == null) {
                javaMethod.name = "DefaultInterfaceMethodName";
            } else {
                javaMethod.name = umlOp.name;
            }
            javaMethod.typeReference = createTypeReference(umlOp.type, customClassType)
            
        }
        add correspondence between umlOp and javaMethod
        update jInterface {
            jInterface.members += javaMethod;
        }
    }
}



reaction Log {
    after any change
    call {
        PropertyConfigurator.configure("log4j.properties")
    }
}