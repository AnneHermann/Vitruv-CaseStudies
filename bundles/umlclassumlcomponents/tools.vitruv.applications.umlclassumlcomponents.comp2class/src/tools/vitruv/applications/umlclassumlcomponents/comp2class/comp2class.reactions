import org.eclipse.emf.ecore.EObject
import org.eclipse.uml2.uml.Component
import org.eclipse.uml2.uml.NamedElement
import org.eclipse.uml2.uml.Package
import org.eclipse.uml2.uml.PackageableElement
import org.eclipse.uml2.uml.PrimitiveType

import static extension tools.vitruv.applications.umlclassumlcomponents.sharedutil.SharedUtil.*

import "http://www.eclipse.org/uml2/5.0.0/UML" as umlcomp
import "http://www.eclipse.org/uml2/5.0.0/UML" as umlclass

reactions: comp2class
in reaction to changes in UML
execute actions in UML


/*******
*Model:*
********/

reaction CreatedCompModel {
	after element umlcomp::Model created and inserted as root
	call { 
		createModelSelfCorrespondence(newValue) 
		//createClassModel(newValue) //TODO This is currently not needed, as we are using one singular meta model  
		createDataTypePackage(newValue)
	} 
}

routine createModelSelfCorrespondence(umlcomp::Model compModel) {
	action {
		add correspondence between compModel and compModel 
	}
}

//TODO This is currently not needed, as we are using one singular meta model
routine createClassModel(umlcomp::Model compModel) {
	action {
		val umlClassModel = create umlclass::Model and initialize {
			umlClassModel.name = compModel.name
			persistProjectRelative(compModel, umlClassModel, FOLDER_NAME + compModel.name + "." + MODEL_FILE_EXTENSION)	
		}
		add correspondence between compModel and umlClassModel
	}
}

routine createDataTypePackage(umlcomp::Model compModel) {
	match {
		val classModel = retrieve umlclass::Model corresponding to compModel
	}
	action {
		val dataTypePackage = create umlclass::Package and initialize {
			dataTypePackage.name = CLASS_DATATYPES_PACKAGE_NAME
		} 
		update classModel {
			classModel.packagedElements += dataTypePackage
		}
		//add correspondence between compModel and dataTypePackage tag with CLASS_DATATYPES_PACKAGE_TAG //TODO think
	} 
}


//TODO This is currently not needed, as we are using one singular meta model
reaction RenamedComponentModel {
	after attribute replaced at umlcomp::Model[name]
	call renameClassModelForComponentModel(affectedEObject)
}

routine renameClassModelForComponentModel(umlcomp::Model compModel) {
	match {
		val classModel = retrieve umlclass::Model corresponding to compModel
	}
	action { 
		update classModel {
			classModel.name = compModel.name
		}
		call {
			persistProjectRelative(compModel, classModel, FOLDER_NAME + compModel.name + "." + MODEL_FILE_EXTENSION)
		}	
	}
}


/*********
*Generic:*
**********/

reaction RenamedElement {
	after attribute replaced at umlcomp::NamedElement[name]
		with !(affectedEObject instanceof Component) && !(affectedEObject instanceof Package) 
	call renameElement(affectedEObject)
}

routine renameElement(umlcomp::NamedElement compElement) {
	action {
		call {
			val correspondingElements = correspondenceModel.getCorrespondingEObjects(#[compElement]).flatten
			for (EObject classElement : correspondingElements) {
				(classElement as NamedElement).name = compElement.name
			}			
		}
	}
}


/***********
*Component:*
************/

reaction CreatedUmlComponent {
	after element umlcomp::Component created and inserted in umlcomp::Model[packagedElement]
	call {
		createClassWithPackage(newValue)
		}
	
}

routine createClassWithPackage(umlcomp::Component umlComp) {
	match {
		val classModel = retrieve umlclass::Model corresponding to umlComp.model
	}
	action {
		val classPackage = create umlclass::Package and initialize {
			classPackage.name = umlComp.name + PACKAGE_SUFFIX
		}
		val umlClass = create umlclass::Class and initialize {
			umlClass.name = umlComp.name
			umlClass.package = classPackage
		}
		update classPackage {			
			classPackage.packagedElements += umlClass
		}
		update classModel {
			classModel.packagedElements += classPackage
		}
		add correspondence between umlComp and umlClass
		add correspondence between umlComp and classPackage
	}
}


reaction RenameComponent {
	after attribute replaced at umlcomp::Component[name]
	call renameClassAndPackage(affectedEObject, newValue)
}

routine renameClassAndPackage(umlcomp::Component umlComp, String newName) { 
	match {
		val umlClass = retrieve umlclass::Class corresponding to umlComp tagged with ""
		val classPackage = retrieve optional umlclass::Package corresponding to umlComp
	}
	action { 
		update umlClass {
			umlClass.name = newName
		}
		call {
			if (classPackage !== null) {
				classPackage.name = newName + PACKAGE_SUFFIX 
			}
		}
	}
}


reaction DeletedComp{
	after element umlcomp::Component deleted and removed from umlcomp::Model[packagedElement]
	call deleteClass(oldValue)
}

routine deleteClass(umlcomp::Component umlComp) { 
	match {
		val umlClass = retrieve umlclass::Class corresponding to umlComp
		val classPackage = retrieve umlclass::Package corresponding to umlComp
	} 
	action { 
		delete umlClass
		call {
			//Delete the containing package if it's empty
			if (classPackage.packagedElements.isEmpty) {
				classPackage.destroy
			} else {
				//Ask if Package and all contents should be deleted 
				val question = "Delete the corresponding Package '" + classPackage.name + "' and all its contained elements?"
				if (userInteracting.modalTextYesNoUserInteracting(question)) {
					for (PackageableElement classElement : classPackage.packagedElements) {
						classElement.destroy
					}
					classPackage.destroy
				}
			}
		}
	}
}


/**********
*Datatpye:*
***********/

reaction CreatedDatatype {
	after element umlcomp::DataType created and inserted in umlcomp::Model[packagedElement]
	call {
		val question = "Is '" + newValue.name + "' a generic/library DataType? If not a class representation will be created."
		if ((newValue instanceof PrimitiveType) || userInteracting.modalTextYesNoUserInteracting(question))
			createDataTypeForDataType(newValue) 
		else 
			createClassForDataType(newValue)	
	}
}


//TODO This is currently only used for self references, as we are using one singular meta model
routine createDataTypeForDataType(umlcomp::DataType compType){
	match {
		val classModel = retrieve umlclass::Model corresponding to compType.model
	}
	action {
		val classType = create umlclass::DataType and initialize {
			classType.name = compType.name
		}
		update classModel {
			classModel.ownedTypes += classType
		}
		add correspondence between compType and classType
	}
}

routine createClassForDataType(umlcomp::DataType compType){
	match {
		val classModel = retrieve umlclass::Model corresponding to compType.model
		
	}
	action {
		val dataTypeClass = create umlclass::Class and initialize {
			dataTypeClass.name = compType.name
			dataTypeClass.package = classModel.packagedElements.filter(Package).filter[name==CLASS_DATATYPES_PACKAGE_NAME].get(0)
		}
		add correspondence between compType and dataTypeClass tag with DATA_TYPE_REPRESENTATION_TAG
	}	
}


reaction AddedDataTypeProperty{
	after element umlcomp::Property created and inserted in umlcomp::DataType[ownedAttribute]
	call addClassDataTypeProperty(newValue, affectedEObject)
}

routine addClassDataTypeProperty(umlcomp::Property compProperty, umlcomp::DataType compDataType) {
	match{
		val dataTypeClass = retrieve umlclass::Class corresponding to compDataType tagged with DATA_TYPE_REPRESENTATION_TAG
	}
	action {
		val classProperty = create umlclass::Property and initialize {
			classProperty.name = compProperty.name
			classProperty.type = compProperty.type
		}
		update dataTypeClass {
			dataTypeClass.ownedAttributes += classProperty
		}
		add correspondence between classProperty and compProperty tag with DATA_TYPE_PROPERTY
	}
}


reaction ChangedDataTypeProperty{
	after attribute replaced at umlcomp::Property[name] 
	call changeClassDataTypeProperty(affectedEObject)
}

routine changeClassDataTypeProperty(umlcomp::Property compProperty) {
	match{
		 val classProperty = retrieve umlclass::Property corresponding to compProperty tagged with DATA_TYPE_PROPERTY	
	}
	action {
		update classProperty { 
			classProperty.name = compProperty.name	
		}
	}
	
}


reaction AddedDataTypeOperation{
	after element umlcomp::Operation created and inserted in umlcomp::DataType[ownedOperation]
	call addDataTypeOperation(newValue, affectedEObject)		
}

routine addDataTypeOperation(umlcomp::Operation compOperation, umlcomp::DataType compDataType) {
	match{
		val dataTypeClass = retrieve umlclass::Class corresponding to compDataType tagged with DATA_TYPE_REPRESENTATION_TAG
	}
	action {
		val classOperation = create umlclass::Operation and initialize {
			classOperation.name = compOperation.name
			classOperation.type = compOperation.type
		}
		update dataTypeClass {
			dataTypeClass.ownedOperations += classOperation
		}
		add correspondence between classOperation and compOperation tag with DATA_TYPE_OPERATION_TAG
	}
}


reaction ChangedDataTypeOperation{
	after attribute replaced at umlcomp::Operation[name] 
	call changeClassDataTypeOperation(affectedEObject)
}

routine changeClassDataTypeOperation(umlcomp::Operation compOperation) {
	match{
		 val classOperation = retrieve umlclass::Operation corresponding to compOperation tagged with DATA_TYPE_OPERATION_TAG	
	}
	action {
		update classOperation { 
			classOperation.name = compOperation.name	
		}
	}
}	
	
	
/************
*Visibility:*
************/

reaction ElementVisibilityChanged {
	after attribute replaced at umlcomp::NamedElement[visibility]
	call changeCorrespondingVisibility(affectedEObject)
}

routine changeCorrespondingVisibility(umlcomp::NamedElement compElement) {
	action {
		call {
			val correspondingElements = correspondenceModel.getCorrespondingEObjects(#[compElement]).flatten
			for (EObject classElement : correspondingElements) {
				(classElement as NamedElement).visibility = compElement.visibility
			}
		}
	}
	
}

	
///************
//*Interfaces:*
//************/
////TODO implement interface reactions
//
//reaction UsesRelationshipCreated {
//	after element umlcomp::Interface created and inserted in umlcomp::Component[useCase] //TODO fix this, different element/set
//	call createRequiresRelationship(newValue, affectedEObject)
//}
//
//routine createRequiresRelationship(umlcomp::Interface newValue, umlcomp::Component affectedEObject) { 
//	action {
//		
//	}
//}

