import org.eclipse.emf.ecore.EObject
import org.eclipse.uml2.uml.Classifier
import org.eclipse.uml2.uml.Component
import org.eclipse.uml2.uml.DataType
import org.eclipse.uml2.uml.NamedElement
import org.eclipse.uml2.uml.Package
import org.eclipse.uml2.uml.PrimitiveType
import tools.vitruv.framework.userinteraction.UserInteractionType

import static extension tools.vitruv.applications.umlclassumlcomponents.class2comp.class2compUtil.*

import "http://www.eclipse.org/uml2/5.0.0/UML" as umlclass
import "http://www.eclipse.org/uml2/5.0.0/UML" as umlcomp

reactions: class2comp
in reaction to changes in UML
execute actions in UML


/*******
*Model:*
********/
//!!!
//This section is currently not needed, as we are using one singular meta model

reaction CreatedClassModel {
	after element umlclass::Model created and inserted as root 
	call createComponentModel(newValue)  
}

routine createComponentModel(umlclass::Model umlClassModel) {
	action {
		val umlComponentModel = create umlcomp::Model and initialize {
			umlComponentModel.name = umlClassModel.name
			persistProjectRelative(umlClassModel, umlComponentModel, "model/" + umlClassModel.name + ".uml")	
		}
		add correspondence between umlClassModel and umlComponentModel
	}
}


reaction RenamedClassModel {
	after attribute replaced at umlclass::Model[name]
	call renameComponentModelForClassModel(affectedEObject)
}

routine renameComponentModelForClassModel( umlclass::Model umlClassModel) {
	match {
		val umlComponentModel = retrieve umlcomp::Model corresponding to umlClassModel
	}
	action { 
		update umlComponentModel {
			umlComponentModel.name = umlClassModel.name
		}
		call {
			persistProjectRelative(umlClassModel, umlComponentModel, "model/" + umlClassModel.name + ".uml")
		}	
	}
}

/*******
*Class:*
********/

reaction CreatedUmlClass {
	after element umlclass::Class created and inserted in umlclass::Package[packagedElement]
	call {
		routineCreatedUmlClass(newValue, affectedEObject)
	}
	
}

routine routineCreatedUmlClass(umlclass::Class umlClass, umlclass::Package classPackage){
	match {
		check {
			val msg = "Create corresponding Component or DataType for created class '" + umlClass.name + "'?"
			return userInteracting.modalTextYesNoUserInteracting(msg)
		}
	}
	action{
		call {
			val msg = "Should '" + umlClass.name + "' be represented by a DataType? If not, it will be a Component."
			if (userInteracting.modalTextYesNoUserInteracting(msg))
        		createDataTypeForClass(umlClass)
        	else {
        		//Create Component:
        		
        		//Component creation for class in Model forbidden:
        		if ( !(classPackage.class.isInstance(Package) || classPackage.class.genericInterfaces.contains(Package)) ) {
        			val String msg2 = "Can't create Component '"  + umlClass.name + "' in Model '"+ classPackage.name
						+"'. No new Component created. Please create '" + umlClass.name + "' in a Package."
					userInteracting.showMessage(UserInteractionType.MODELESS, msg2)
        		} else {
	        		//Get Component matching to Package
					val comps = correspondenceModel.getCorrespondingEObjects(#[classPackage]).flatten.filter(Component)
					var Component matchedPackageComponent = null
					if (comps.size != 0) 
						matchedPackageComponent = comps.get(0)
	        		
	        		if (matchedPackageComponent === null) { //Check if this Package already has a Component
	        			createUmlComponent(umlClass)
		        	} else {
		        		val String msg3 = "Package '" + classPackage.name + "' already has a corresponding Component '"
		        			+ matchedPackageComponent.name + "'. No new Component created. Create '" + umlClass.name + "' in a different Package."
						userInteracting.showMessage(UserInteractionType.MODELESS, msg3)
		        	}
		        	
	        	}
	        }
		}
	}
}

routine createUmlComponent(umlclass::Class umlClass) {
	match {
		val compModel = retrieve umlcomp::Model corresponding to umlClass.model
	}
	action {
		val umlComponent = create umlcomp::Component and initialize {
			umlComponent.name = umlClass.name
		}
		update compModel 
			compModel.packagedElements += umlComponent
		
		add correspondence between umlClass and umlComponent
		
		call {
			val classPackage = umlClass.package
			//Only add correspondence if classPackage is not a Model (or ModelImpl)
			//if (classPackage.class.isInstance(Package) || classPackage.class.genericInterfaces.contains(Package)) //TODO out for now, back in later? 
				correspondenceModel.createAndAddCorrespondence(#[umlComponent], #[classPackage])				
				//add correspondence between umlComponent and umlClass.package
		}
	}
}

routine createDataTypeForClass(umlclass::Class umlClass) {
	match {
		val compModel = retrieve umlcomp::Model corresponding to umlClass.model
	}
	action {
		val compDataType = create umlcomp::DataType and initialize {
			compDataType.name = umlClass.name 
			compDataType.package = umlClass.package
		}
		update compModel
			compModel.packagedElements += compDataType
		
		add correspondence between umlClass and compDataType tag with "DataTypeRepresentation"
	}	
}


reaction RenameClass {
	after attribute replaced at umlclass::Class[name]
	call {
		renameComponent(affectedEObject)
	}
}

routine renameComponent(umlclass::Class umlClass) { 
	match {
		val umlComponent = retrieve umlcomp::Component corresponding to umlClass
			with umlComponent.name.equals(umlClass.name)
	}
	action { 
		update umlComponent {
			umlComponent.name = umlClass.name
		}
	}
}


reaction DeletedClass{
	after element umlclass::Class deleted and removed from umlclass::Package[packagedElement]
	call{
		deleteComponent(oldValue, "")
	}
}

routine deleteComponent(umlclass::Class umlClass, String expectedTag) { 
	match {
		val umlComponent = retrieve umlcomp::Component corresponding to umlClass tagged with expectedTag
	} 
	action { 
		delete umlComponent
	}
}


reaction RenamedElement {
	after attribute replaced at umlclass::NamedElement[name]
	call renameElement(affectedEObject)
}

routine renameElement(umlcomp::NamedElement classElement) {
	match {
		val compElement = retrieve umlcomp::NamedElement corresponding to classElement tagged with "" 
		//only rename generically for untagged elements
	}
	action {
		update compElement {
			compElement.name = classElement.name
		}
	}
}


/***********
*Datatypes:*
************/
//!!!
//This section is currently not needed, as we are using one singular meta model

reaction CreatedPrimitiveDataType {
	after element umlclass::PrimitiveType created and inserted in umlclass::Package[packagedElement]
	call createPrimitiveDataType(newValue)
}

routine createPrimitiveDataType(umlclass::PrimitiveType classType) {
	action {
		val compType = create umlcomp::PrimitiveType and initialize {
			compType.name = classType.name
		}
		update compType.package {
			compType.package.ownedTypes += compType
		}
		add correspondence between compType and classType
	}
}


reaction CreatedDataType {
	after element umlclass::DataType created and inserted in umlclass::Package[packagedElement] 
		with !(newValue instanceof PrimitiveType)
	call createDataType(newValue)
}

routine createDataType(umlclass::DataType classType) {
	action {
		val compType = create umlcomp::DataType and initialize {
			compType.name = classType.name
		}
		update compType.package {
			compType.package.ownedTypes += compType
		}
		add correspondence between classType and compType
	}
}

/************
*Attributes:*
*************/

reaction ClassAttributeCreated {
    after element umlclass::Property created and inserted in umlclass::Class[ownedAttribute]
    call {
        createCompAttribute(affectedEObject, newValue)
    }
}

//TODO change to new datatype structure
routine createCompAttribute(umlclass::Class umlClass, umlclass::Property classAttribute) {
    match {
        val component = retrieve umlcomp::Component corresponding to umlClass
    }
    action {
        val componentAttribute = create umlcomp::Property and initialize {
            if (classAttribute.name === null) {
                componentAttribute.name = "DefaultAttributeName"
            } else {
                componentAttribute.name = classAttribute.name
            }
            componentAttribute.datatype = classAttribute.datatype
        }
        update component {
          component.members += componentAttribute
        }
        add correspondence between classAttribute and componentAttribute
    }
}


reaction ClassAttributeRenamed {
    after attribute replaced at umlclass::Property[name]
    call renameComponentAttribute(affectedEObject)
}

routine renameComponentAttribute(umlclass::Property classAttribute) {
    match {
        val componentAttribute = retrieve umlcomp::Property corresponding to classAttribute
    }
    action {
        update componentAttribute {
            componentAttribute.name = classAttribute.name
        }
    }
}


reaction ClassAttributeDeleted {
    after element umlclass::Property deleted and removed from umlclass::Class[ownedAttribute]
    call deleteComponentAttribute(oldValue)
}

routine deleteComponentAttribute(umlclass::Property classAttribute) {
    match {
        val componentAttribute = retrieve umlcomp::Property corresponding to classAttribute
    }
    action {
        delete componentAttribute
        remove correspondence between classAttribute and componentAttribute
    }
}


reaction ChangedPropertyType {
	after element replaced at umlclass::Property[type] 
		with (newValue instanceof DataType)
	call changePropertyType(affectedEObject, (newValue as DataType))
}

routine changePropertyType(umlclass::Property classProperty, umlclass::DataType classType) {
	match {
		val compProperty = retrieve umlclass::Property corresponding to classProperty
		val compType = retrieve umlcomp::DataType corresponding to classType
	}
	action {
		update compProperty {
			compProperty.type = compType
		}
	}
}


/**********
*Packages:*
***********/

reaction CreatePackage {
	after element created and inserted in umlclass::Model[packagedElement]
		with (newValue instanceof Package)
	call {
		createdPackage(newValue as Package)		
	}
}

routine createdPackage(umlclass::Package classPackage) {
	match {
		val compModel = retrieve umlcomp::Model corresponding to classPackage.model
		check {
			val msg = "Do you want to link this Package '" + classPackage.name + "' to an existing Component?"
			return userInteracting.modalTextYesNoUserInteracting(msg)
		}
	}
	action {
		call { 
			val msg2 = "Choose an existing Component to link Package '" + classPackage.name + "' to:"
			//Get list of existing components as options for dialog
			val componentsList = compModel.packagedElements.filter(Component).toList
			if (componentsList.size != 0) { 
				val options = componentsList.map[e | e.name] 			
				val selection = userInteracting.modalTextUserinteracting(msg2, options)		
				//Use selection to assign new package
				val umlComponent = componentsList.get(selection)
				assignNewPackage(classPackage, umlComponent)
			} else {
				userInteracting.showMessage(UserInteractionType.MODELESS, "No available Component found")
			}
		}
					
	}
}

routine assignNewPackage(umlclass::Package newPackage, umlclass::Component umlComponent) {
	action {
		call {
			val packages = correspondenceModel.getCorrespondingEObjects(#[umlComponent]).flatten.filter(Package)
			var Package oldPackage = null
			if (packages.size != 0) 
				oldPackage = packages.get(0)
			
			
			if (oldPackage === null) {
				correspondenceModel.createAndAddCorrespondence(#[umlComponent], #[newPackage])
				//add correspondence between umlComponent and newPackage
			} else {
				val String msg = "Chosen Component is already linked to existing Package '" + oldPackage.name + "'."
				userInteracting.showMessage(UserInteractionType.MODELESS, msg)
			}
		}
	} 
}


reaction MoveClassToDifferentPackage {
	after element replaced at umlclass::Class[package]
	call movedClassToDifferentPackage(affectedEObject, oldValue, newValue)
}

routine movedClassToDifferentPackage(umlclass::Class umlClass, umlclass::Package oldPackage, umlclass::Package newPackage) {
	match {
		val packageOldComp = retrieve optional umlcomp::Component corresponding to oldPackage
		val packageNewComp = retrieve optional umlcomp::Component corresponding to newPackage
		val compLinked = retrieve optional umlcomp::Component corresponding to umlClass
		
		//TODO check if class has no corresponding component
		//require absence of umlcomp::Component corresponding to umlClass
	}
	action {
		call {
			if (packageOldComp !== null)
				removeCorrespondence(umlClass as Classifier, packageOldComp as Classifier) //shouldn't happen, TODO check this
		}		
		
		
		
		//add correspondence between umlClass and packageNewComp
		
		//TODO Implement rename handling concept
		
	}
}

routine removeCorrespondence(umlclass::Classifier classObject, umlcomp::Classifier compObject) {
	action {
		remove correspondence between classObject and compObject
	}
}


//TODO reaction RenamePackage, needed? rename component not possible as rename class would be required too


/***********
*Visibility:*
************/

reaction ElementVisibilityChanged {
	after attribute replaced at umlclass::NamedElement[visibility]
	call changeCorrespondingVisibility(affectedEObject)
}

routine changeCorrespondingVisibility(umlclass::NamedElement classElement) {
	action {
		call {
			val correspondingElements = correspondenceModel.getCorrespondingEObjects(#[classElement]).flatten
			for (EObject compElement : correspondingElements) {
				(compElement as NamedElement).visibility = classElement.visibility
			}
		}
	}
}


/************
*Interfaces:*
*************/

//TODO: implement correctly
reaction CreatedInterface {
	after element umlclass::Interface created and inserted in umlclass::Model[packagedElement]
	call createInterface(newValue)
}

routine createInterface(umlclass::Interface classInterface) {
	action {
		val compInterface = create umlcomp::Interface and initialize {
			compInterface.name = classInterface.name
		}
		update classInterface.package {
			classInterface.package.packagedElements += compInterface
		}
		add correspondence between classInterface and compInterface
	}
}


//***Provided***

reaction InterfaceRealized{
	after element umlclass::Interface created and inserted in umlclass::Class[interfaceRealization] //TODO fix this, different element
	call createInterfaceRealization(affectedEObject, newValue)
}

routine createInterfaceRealization(umlclass::Class umlClass, umlclass::Interface classInterface) {
	match {
		val umlComponent = retrieve umlcomp::Component corresponding to umlClass
	}
	action {
		val interfaceRealization = create umlcomp::InterfaceRealization and initialize {
			interfaceRealization.name = classInterface.name
			interfaceRealization.clients += umlComponent
			interfaceRealization.suppliers += classInterface
		}
		update umlComponent {
			umlComponent.interfaceRealizations += interfaceRealization
		}
		add correspondence between interfaceRealization and classInterface
	}
	
}


//TODO ?? merge with required?
reaction InterfaceDeleted {
	after element removed from umlclass::Class[interfaceRealization]
	call deleteInterfaceRealization(oldValue)
}
routine deleteInterfaceRealization(umlclass::InterfaceRealization classInterface) {
	match {
		val interfaceRealization = retrieve umlcomp::InterfaceRealization corresponding to classInterface
	}
	action {
		delete interfaceRealization
	}
}

//***Required***

reaction AddedUsesRelationship {
	after element umlclass::Interface created and inserted in umlclass::Class[useCase] //TODO useCase correct??
	call addRequiredRole(affectedEObject, newValue)
}

routine addRequiredRole(umlclass::Class umlClass, umlclass::Interface classInterface) {
	match {
		val umlComponent = retrieve umlcomp::Component corresponding to umlClass
	}
	action {
		val usage = create umlcomp::Usage and initialize {
			usage.name = classInterface.name
			usage.clients += umlComponent
			usage.suppliers += classInterface
		}
		update umlComponent {
			umlComponent.packagedElements += usage
		}
		add correspondence between usage and classInterface
	}
}


