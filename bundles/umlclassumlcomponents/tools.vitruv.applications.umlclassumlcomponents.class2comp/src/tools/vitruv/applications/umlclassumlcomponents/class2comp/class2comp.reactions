import org.eclipse.uml2.uml.DataType
import org.eclipse.uml2.uml.PrimitiveType
import org.eclipse.uml2.uml.Package
import org.eclipse.uml2.uml.Component
import org.eclipse.uml2.uml.Classifier

import static extension tools.vitruv.applications.umlclassumlcomponents.class2comp.class2compUtil.*

import "http://www.eclipse.org/uml2/5.0.0/UML" as umlclass
import "http://www.eclipse.org/uml2/5.0.0/UML" as umlcomp

reactions: class2comp
in reaction to changes in UML
execute actions in UML


/*******
*Model:*
********/
//!!!
//This section is currently not needed, as we are using one singular meta model

reaction CreatedClassModel {
	after element umlclass::Model created and inserted as root 
	call createComponentModel(newValue)  
}

routine createComponentModel(umlclass::Model umlClassModel) {
	action {
		val umlComponentModel = create umlcomp::Model and initialize {
			umlComponentModel.name = umlClassModel.name
			persistProjectRelative(umlClassModel, umlComponentModel, "model/" + umlClassModel.name + ".uml")	
		}
		add correspondence between umlClassModel and umlComponentModel
	}
}


reaction RenamedClassModel {
	after attribute replaced at umlclass::Model[name]
	call renameComponentModelForClassModel(affectedEObject)
}

routine renameComponentModelForClassModel( umlclass::Model umlClassModel) {
	match {
		val umlComponentModel = retrieve umlcomp::Model corresponding to umlClassModel
	}
	action { 
		update umlComponentModel {
			umlComponentModel.name = umlClassModel.name
		}
		call {
			persistProjectRelative(umlClassModel, umlComponentModel, "model/" + umlClassModel.name + ".uml")
		}	
	}
}

/*******
*Class:*
********/
reaction CreatedUmlClass {
	after element umlclass::Class created and inserted in umlclass::Package[packagedElement]
	call {
		routineCreatedUmlClass(newValue)
	}
	
}

routine routineCreatedUmlClass(umlclass::Class umlClass){
	match{
		check {
			val msg = "Create corresponding Component or DataType for created class '" + umlClass.name + "'?"
			return userInteracting.modalTextYesNoUserInteracting(msg)
		}
	}
	action{
		call {
			val msg = "Should '" + umlClass.name + "' be represented by a DataType?"
			if (userInteracting.modalTextYesNoUserInteracting(msg))
        		createDataTypeForClass(umlClass)
        	else {
        		createUmlComponent(umlClass)			
        	}
		}
	}
}

routine createUmlComponent(umlclass::Class umlClass) {
	match {
		val compModel = retrieve umlcomp::Model corresponding to umlClass.model
	}
	action {
		val umlComponent = create umlcomp::Component and initialize {
			umlComponent.name = umlClass.name
		}
		update compModel 
			compModel.packagedElements += umlComponent
		
		add correspondence between umlClass and umlComponent
	}
}

routine createDataTypeForClass(umlclass::Class umlClass) {
	match {
		val compModel = retrieve umlcomp::Model corresponding to umlClass.model
	}
	action {
		val compDataType = create umlcomp::DataType and initialize {
			compDataType.name = umlClass.name 
			compDataType.package = umlClass.package
		}
		update compModel
			compModel.packagedElements += compDataType
		
		add correspondence between umlClass and compDataType tag with "DataTypeRepresentation"
	}	
}


reaction RenameClass {
	after attribute replaced at umlclass::Class[name]
	call {
		renameComponent(affectedEObject)
	}
}

routine renameComponent(umlclass::Class umlClass) { 
	match {
		val umlComponent = retrieve umlcomp::Component corresponding to umlClass
			with umlComponent.name.equals(umlClass.name)
	}
	action { 
		update umlComponent {
			umlComponent.name = umlClass.name
		}
	}
}


reaction DeletedClass{
	after element umlclass::Class deleted and removed from umlclass::Package[packagedElement]
	call{
		deleteComponent(oldValue, oldValue.name, "")
	}
}

routine deleteComponent(umlclass::Class umlClass, String packageName, String expectedTag) { 
	match {
		val umlComponent = retrieve umlcomp::Component corresponding to umlClass tagged with expectedTag
	} 
	action { 
		delete umlComponent
	}
}


reaction RenamedElement {
	after attribute replaced at umlclass::NamedElement[name]
	call renameElement(affectedEObject)
}

routine renameElement(umlcomp::NamedElement classElement) {
	match {
		val compElement = retrieve umlcomp::NamedElement corresponding to classElement tagged with "" 
		//only rename generically for untagged elements
	}
	action {
		update compElement {
			compElement.name = classElement.name
		}
	}
}


/***********
*Datatypes:*
************/
//!!!
//This section is currently not needed, as we are using one singular meta model

reaction CreatedPrimitiveDataType {
	after element umlclass::PrimitiveType created and inserted in umlclass::Package[packagedElement]
	call createPrimitiveDataType(newValue)
}

routine createPrimitiveDataType(umlclass::PrimitiveType classType) {
	action {
		val compType = create umlcomp::PrimitiveType and initialize {
			compType.name = classType.name
		}
		update compType.package {
			compType.package.ownedTypes += compType
		}
		add correspondence between compType and classType
	}
}


reaction CreatedDataType {
	after element umlclass::DataType created and inserted in umlclass::Package[packagedElement] 
		with !(newValue instanceof PrimitiveType)
	call createDataType(newValue)
}

routine createDataType(umlclass::DataType classType) {
	action {
		val compType = create umlcomp::DataType and initialize {
			compType.name = classType.name
		}
		update compType.package {
			compType.package.ownedTypes += compType
		}
		add correspondence between classType and compType
	}
}

/***********
*Attributes:*
************/

reaction ClassAttributeCreated {
    after element umlclass::Property created and inserted in umlclass::Class[ownedAttribute]
    call {
        createCompAttribute(affectedEObject, newValue)
    }
}

//TODO change to new datatype structure
routine createCompAttribute(umlclass::Class umlClass, umlclass::Property classAttribute) {
    match {
        val component = retrieve umlcomp::Component corresponding to umlClass
    }
    action {
        val componentAttribute = create umlcomp::Property and initialize {
            if (classAttribute.name === null) {
                componentAttribute.name = "DefaultAttributeName"
            } else {
                componentAttribute.name = classAttribute.name
            }
            componentAttribute.datatype = classAttribute.datatype
        }
        update component {
          component.members += componentAttribute
        }
        add correspondence between classAttribute and componentAttribute
    }
}


reaction ClassAttributeRenamed {
    after attribute replaced at umlclass::Property[name]
    call renameComponentAttribute(affectedEObject)
}

routine renameComponentAttribute(umlclass::Property classAttribute) {
    match {
        val componentAttribute = retrieve umlcomp::Property corresponding to classAttribute
    }
    action {
        update componentAttribute {
            componentAttribute.name = classAttribute.name
        }
    }
}


reaction ClassAttributeDeleted {
    after element umlclass::Property deleted and removed from umlclass::Class[ownedAttribute]
    call deleteComponentAttribute(oldValue)
}

routine deleteComponentAttribute(umlclass::Property classAttribute) {
    match {
        val componentAttribute = retrieve umlcomp::Property corresponding to classAttribute
    }
    action {
        delete componentAttribute
        remove correspondence between classAttribute and componentAttribute
    }
}


reaction ChangedPropertyType {
	after element replaced at umlclass::Property[type] 
		with (newValue instanceof DataType)
	call changePropertyType(affectedEObject, (newValue as DataType))
}

routine changePropertyType(umlclass::Property classProperty, umlclass::DataType classType) {
	match {
		val compProperty = retrieve umlclass::Property corresponding to classProperty
		val compType = retrieve umlcomp::DataType corresponding to classType
	}
	action {
		update compProperty {
			compProperty.type = compType
		}
	}
}


/**********
*Packages:*
***********/

reaction CreatePackage {
	after element created and inserted in umlclass::Model[packagedElement]
		with (newValue instanceof Package)
	call {
		if (false) //TODO: add back in once correspondeces are added 
			createdPackage(newValue as Package)
	}
}

routine createdPackage(umlclass::Package classPackage) {
	match {
		val umlModel = retrieve umlcomp::Model corresponding to classPackage
		check {
			val msg = "Do you want to link this Package '" + classPackage.name + "' to an existing Component?"
			return userInteracting.modalTextYesNoUserInteracting(msg)
		}
	}
	action {
		call { 
			val msg2 = "Choose an existing Component to link Package '" + classPackage.name + "' to:"
			//Get list of existing components as options for dialog
			val componentsList = umlModel.packagedElements.filter(Component).toList
			val options = componentsList.map[e | e.name] 			
			val selection = userInteracting.modalTextUserinteracting(msg2, options)		
			//Use selection to assign new package
			val umlComponent = componentsList.get(selection)
			assignNewPackage(classPackage, umlComponent)
		}
					
	}
}

routine assignNewPackage(umlclass::Package classPackage, umlclass::Component umlComponent) {
	action {
		add correspondence between umlComponent and classPackage	
	} 

}


reaction MoveClassToDifferentPackage {
	after element replaced at umlclass::Class[package]
	call movedClassToDifferentPackage(affectedEObject, oldValue, newValue)
}

routine movedClassToDifferentPackage(umlclass::Class umlClass, umlclass::Package oldPackage, umlclass::Package newPackage) {
	match {
		val packageOldComp = retrieve optional umlcomp::Component corresponding to oldPackage
		val packageNewComp = retrieve optional umlcomp::Component corresponding to newPackage
		val compLinked = retrieve optional umlcomp::Component corresponding to umlClass
		
		//TODO check if class has no corresponding component
		//require absence of umlcomp::Component corresponding to umlClass
	}
	action {
		call {
			if (packageOldComp !== null)
				removeCorrespondence(umlClass as Classifier, packageOldComp as Classifier) //shouldn't happen, TODO check this
		}		
		
		
		
		//add correspondence between umlClass and packageNewComp
		
		//TODO Implement rename handling concept
		
	}
}

routine removeCorrespondence(umlclass::Classifier classObject, umlcomp::Classifier compObject) {
	action {
		remove correspondence between classObject and compObject
	}
}


//TODO reaction RenamePackage, needed? rename component not possible as rename class would be required too



/************
*Interfaces:*
************/

//TODO: implement correctly
reaction CreatedInterface {
	after element umlclass::Interface created and inserted in umlclass::Model[packagedElement]
	call createInterface(newValue)
}

routine createInterface(umlclass::Interface classInterface) {
	action {
		val compInterface = create umlcomp::Interface and initialize {
			compInterface.name = classInterface.name
		}
		update classInterface.package {
			classInterface.package.packagedElements += compInterface
		}
		add correspondence between classInterface and compInterface
	}
}


//***Provided***

reaction InterfaceRealized{
	after element umlclass::Interface created and inserted in umlclass::Class[interfaceRealization] //TODO fix this, different element
	call createInterfaceRealization(affectedEObject, newValue)
}

routine createInterfaceRealization(umlclass::Class umlClass, umlclass::Interface classInterface) {
	match {
		val umlComponent = retrieve umlcomp::Component corresponding to umlClass
	}
	action {
		val interfaceRealization = create umlcomp::InterfaceRealization and initialize {
			interfaceRealization.name = classInterface.name
			interfaceRealization.clients += umlComponent
			interfaceRealization.suppliers += classInterface
		}
		update umlComponent {
			umlComponent.interfaceRealizations += interfaceRealization
		}
		add correspondence between interfaceRealization and classInterface
	}
	
}


//TODO ?? merge with required?
reaction InterfaceDeleted {
	after element removed from umlclass::Class[interfaceRealization]
	call deleteInterfaceRealization(oldValue)
}
routine deleteInterfaceRealization(umlclass::InterfaceRealization classInterface) {
	match {
		val interfaceRealization = retrieve umlcomp::InterfaceRealization corresponding to classInterface
	}
	action {
		delete interfaceRealization
	}
}

//***Required***

reaction AddedUsesRelationship {
	after element umlclass::Interface created and inserted in umlclass::Class[useCase] //TODO useCase correct??
	call addRequiredRole(affectedEObject, newValue)
}

routine addRequiredRole(umlclass::Class umlClass, umlclass::Interface classInterface) {
	match {
		val umlComponent = retrieve umlcomp::Component corresponding to umlClass
	}
	action {
		val usage = create umlcomp::Usage and initialize {
			usage.name = classInterface.name
			usage.clients += umlComponent
			usage.suppliers += classInterface
		}
		update umlComponent {
			umlComponent.packagedElements += usage
		}
		add correspondence between usage and classInterface
	}
}


