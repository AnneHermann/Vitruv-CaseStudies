import org.eclipse.emf.ecore.EObject
import org.eclipse.uml2.uml.Class
import org.eclipse.uml2.uml.Classifier
import org.eclipse.uml2.uml.Component
import org.eclipse.uml2.uml.DataType
import org.eclipse.uml2.uml.Model
import org.eclipse.uml2.uml.NamedElement
import org.eclipse.uml2.uml.Package
import org.eclipse.uml2.uml.PrimitiveType
import tools.vitruv.framework.userinteraction.UserInteractionType

import static extension tools.vitruv.applications.umlclassumlcomponents.sharedutil.SharedUtil.*

import "http://www.eclipse.org/uml2/5.0.0/UML" as umlclass
import "http://www.eclipse.org/uml2/5.0.0/UML" as umlcomp

reactions: class2comp
in reaction to changes in UML
execute actions in UML


/*******
*Model:*
********/

reaction CreatedClassModel {
	after element umlclass::Model created and inserted as root 
	call createModelSelfCorrespondence(newValue)
	//call createComponentModel(newValue) //TODO This is currently not needed, as we are using one singular meta model
}


routine createModelSelfCorrespondence(umlcomp::Model umlCompModel) {
	action {
		add correspondence between umlCompModel and umlCompModel 
	}
}

//TODO This is currently not needed, as we are using one singular meta model
routine createComponentModel(umlclass::Model umlClassModel) {
	action {
		val compModel = create umlcomp::Model and initialize {
			compModel.name = umlClassModel.name
			persistProjectRelative(umlClassModel, compModel, FOLDER_NAME + umlClassModel.name + "." + MODEL_FILE_EXTENSION)	
		}
		add correspondence between umlClassModel and compModel
	}
}


//TODO This is currently not needed, as we are using one singular meta model
reaction RenamedClassModel {
	after attribute replaced at umlclass::Model[name]
	call renameComponentModelForClassModel(affectedEObject)
}

routine renameComponentModelForClassModel( umlclass::Model umlClassModel) {
	match {
		val compModel = retrieve umlcomp::Model corresponding to umlClassModel
	}
	action { 
		update compModel {
			compModel.name = umlClassModel.name
		}
		call {
			persistProjectRelative(umlClassModel, compModel, FOLDER_NAME + umlClassModel.name + "." + MODEL_FILE_EXTENSION)
		}	
	}
}


/*********
*Generic:*
**********/

reaction RenamedElement {
	after attribute replaced at umlclass::NamedElement[name]
		with !(affectedEObject instanceof Class) && !(affectedEObject instanceof Package) 
	call renameElement(affectedEObject)
}

routine renameElement(umlclass::NamedElement classElement) {
	action {
		call {
			val correspondingElements = correspondenceModel.getCorrespondingEObjects(#[classElement]).flatten
			for (EObject compElement : correspondingElements) {
				(compElement as NamedElement).name = classElement.name
			}			
		}
	}
}


/*******
*Class:*
********/

reaction CreatedUmlClass {
	after element umlclass::Class created and inserted in umlclass::Package[packagedElement]
	call {
		routineCreatedUmlClass(newValue, affectedEObject)
	}
	
}

routine routineCreatedUmlClass(umlclass::Class umlClass, umlclass::Package classPackage){
	match {
		val compModel = retrieve umlcomp::Model corresponding to umlClass.model	
	}
	action{
		call {	
			//Component and DataType creation for Class in Model forbidden:
    		if (!(classPackage instanceof Model)) {
	    		//If the class is created in the DataType Package, consider it as a DataType
	    		if (classPackage.name == CLASS_DATATYPES_PACKAGE_NAME) {
	    			createDataTypeForClass(umlClass)
	    		} else {			
					//Check if this Package already has a corresponding Component
					//Get Component matching to Package
					val comps = correspondenceModel.getCorrespondingEObjects(#[classPackage]).flatten.filter(Component)
					var Component matchedPackageComponent = if(!comps.isEmpty) comps.get(0) else null				        		
		    		if (matchedPackageComponent === null) {    
		    			val question = "Should '" + umlClass.name + "' be represented by a Component?"
						if (userInteracting.modalTextYesNoUserInteracting(question))
		    				createUmlComponentForClass(umlClass)
		        	} 
	        	}
	        }
		}
	}
}

routine createUmlComponentForClass(umlclass::Class umlClass) {
	match {
		val compModel = retrieve umlcomp::Model corresponding to umlClass.model
	}
	action {
		val umlComp = create umlcomp::Component and initialize {
			umlComp.name = umlClass.name
		}
		update compModel 
			compModel.packagedElements += umlComp
		
		add correspondence between umlClass and umlComp
		
		call {
			val classPackage = umlClass.package
			correspondenceModel.createAndAddCorrespondence(#[umlComp], #[classPackage])				
			//add correspondence between umlComponent and umlClass.package
		}
	}
}

routine createDataTypeForClass(umlclass::Class umlClass) {
	match {
		val compModel = retrieve umlcomp::Model corresponding to umlClass.model
	}
	action {
		val compDataType = create umlcomp::DataType and initialize {
			compDataType.name = umlClass.name 
		}
		update compModel
			compModel.packagedElements += compDataType
		
		add correspondence between umlClass and compDataType tag with DATA_TYPE_REPRESENTATION_TAG
	}	
}


reaction RenameClass {
	after attribute replaced at umlclass::Class[name]
	call {
		renameComponent(affectedEObject)
	}
}

routine renameComponent(umlclass::Class umlClass) { 
	match {
		val umlComp = retrieve umlcomp::Component corresponding to umlClass
	}
	action { 
		update umlComp {
			umlComp.name = umlClass.name
		}
	}
}


reaction DeletedClass{
	after element umlclass::Class deleted and removed from umlclass::Package[packagedElement]
	call deleteComponent(oldValue)
}

routine deleteComponent(umlclass::Class umlClass) { 
	match {
		val umlComp = retrieve umlcomp::Component corresponding to umlClass
	} 
	action { 
		delete umlComp
	}
}


/***********
*Datatypes:*
************/

//TODO This is currently only used for self references, as we are using one singular meta model
reaction CreatedPrimitiveDataType {
	after element umlclass::PrimitiveType created and inserted in umlclass::Package[packagedElement]
	call createPrimitiveDataType(newValue)
}

routine createPrimitiveDataType(umlclass::PrimitiveType classType) {
	action {
		val compType = create umlcomp::PrimitiveType and initialize {
			compType.name = classType.name
		}
		update compType.package {
			compType.package.packagedElements += compType
		}
		add correspondence between compType and classType
	}
}

//TODO This is currently only used for self references, as we are using one singular meta model
reaction CreatedDataType {
	after element umlclass::DataType created and inserted in umlclass::Package[packagedElement] 
		with !(newValue instanceof PrimitiveType)
	call createDataType(newValue)
}

routine createDataType(umlclass::DataType classType) {
	action {
		val compType = create umlcomp::DataType and initialize {
			compType.name = classType.name
		}
		update compType.package {
			compType.package.packagedElements += compType
		}
		add correspondence between classType and compType
	}
}

//TODO change all of the following to apply only for datatypes
reaction DataTypeClassAttributeCreated {
    after element umlclass::Property created and inserted in umlclass::Class[ownedAttribute]
    call {
        createCompDataTypeAttribute(affectedEObject, newValue)
    }
}

routine createCompDataTypeAttribute(umlclass::Class umlClass, umlclass::Property classAttribute) {
    match {
        val compDataType = retrieve umlcomp::DataType corresponding to umlClass tagged with DATA_TYPE_REPRESENTATION_TAG
    }
    action {
        val compAttribute = create umlcomp::Property and initialize {
            if (classAttribute.name === null) {
                compAttribute.name = "DefaultAttributeName"
            } else {
                compAttribute.name = classAttribute.name
            }
            compAttribute.datatype = classAttribute.datatype
        }
        update compDataType {
          compDataType.members += compAttribute
        }
        add correspondence between classAttribute and compAttribute
    }
}


reaction DataTypeClassAttributeRenamed {
    after attribute replaced at umlclass::Property[name]
    call renameCompDataTypeAttribute(affectedEObject)
}

routine renameCompDataTypeAttribute(umlclass::Property classAttribute) {
    match {
        val compAttribute = retrieve umlcomp::Property corresponding to classAttribute tagged with DATA_TYPE_PROPERTY
    }
    action {
        update compAttribute {
            compAttribute.name = classAttribute.name
        }
    }
}


reaction DataTypeClassAttributeDeleted {
    after element umlclass::Property deleted and removed from umlclass::Class[ownedAttribute]
    call deleteCompDataTypeAttribute(oldValue)
}

routine deleteCompDataTypeAttribute(umlclass::Property classAttribute) {
    match {
        val compAttribute = retrieve umlcomp::Property corresponding to classAttribute tagged with DATA_TYPE_PROPERTY
    }
    action {
        delete compAttribute
        remove correspondence between classAttribute and compAttribute
    }
}


reaction ChangedAttributeType {
	after element replaced at umlclass::Property[type] 
		with (newValue instanceof DataType)
	call changeAttributeType(affectedEObject, (newValue as DataType))
}

routine changeAttributeType(umlclass::Property classProperty, umlclass::DataType classType) {
	match {
		val compAttribute = retrieve umlclass::Property corresponding to classProperty tagged with DATA_TYPE_PROPERTY
		val compType = retrieve umlcomp::DataType corresponding to classType
	}
	action {
		update compAttribute {
			compAttribute.type = compType
		}
	}
}


/**********
*Packages:*
***********/

reaction CreatePackage {
	after element created and inserted in umlclass::Model[packagedElement]
		with (newValue instanceof Package)
	call createdPackage(newValue as Package)
}

//TODO only match if name matches Component?
routine createdPackage(umlclass::Package classPackage) {
	match {
		val compModel = retrieve umlcomp::Model corresponding to classPackage.model
		check {
			val question = "Do you want to link this Package '" + classPackage.name + "' to an existing Component?"
			return userInteracting.modalTextYesNoUserInteracting(question)
		}
	}
	action {
		call { 
			val question = "Choose an existing Component to link Package '" + classPackage.name + "' to:"
			//Get list of existing components as options for dialog
			val componentsList = compModel.packagedElements.filter(Component).toList
			if (!componentsList.isEmpty) { 
				val options = componentsList.map[e | e.name] 			
				val selection = userInteracting.modalTextUserinteracting(question, options)		
				//Use selection to assign new package
				val umlComp = componentsList.get(selection)
				assignNewPackage(classPackage, umlComp)
			} else {
				userInteracting.showMessage(UserInteractionType.MODELESS, "No available Component found")
			}
		}
					
	}
}

routine assignNewPackage(umlclass::Package newPackage, umlclass::Component umlComponent) { //TODO rewrite this to fit new package linking
	action {
		call {
			val packages = correspondenceModel.getCorrespondingEObjects(#[umlComponent]).flatten.filter(Package)
			var Package oldPackage = if(!packages.isEmpty) packages.get(0) else null			
			
			if (oldPackage === null) {
				correspondenceModel.createAndAddCorrespondence(#[umlComponent], #[newPackage])
				//add correspondence between umlComponent and newPackage
			} else {
				val String errorMsg = "Chosen Component is already linked to existing Package '" + oldPackage.name + "'."
				userInteracting.showMessage(UserInteractionType.MODELESS, errorMsg)
			}
		}
	} 
}


reaction MoveClassToDifferentPackage {
	after element replaced at umlclass::Class[package]
	call movedClassToDifferentPackage(affectedEObject, oldValue, newValue)
}

routine movedClassToDifferentPackage(umlclass::Class umlClass, umlclass::Package oldPackage, umlclass::Package newPackage) {
	match {
		val packageOldComp = retrieve optional umlcomp::Component corresponding to oldPackage
		val packageNewComp = retrieve optional umlcomp::Component corresponding to newPackage
		val compLinked = retrieve optional umlcomp::Component corresponding to umlClass
		
		//TODO check if class has no corresponding component?
		//require absence of umlcomp::Component corresponding to umlClass
	}
	action {
		call {
			if (packageOldComp !== null)
				removeCorrespondence(umlClass as Classifier, packageOldComp as Classifier) //shouldn't happen, TODO check this
		}			
		//add correspondence between umlClass and packageNewComp
		
		//TODO Implement rename handling concept
		
	}
}

routine removeCorrespondence(umlclass::Classifier classObject, umlcomp::Classifier compObject) {
	action {
		remove correspondence between classObject and compObject
	}
}

reaction PackageRenamed {
	after attribute replaced at umlclass::Package[name]
	call routinePackageRenamed(affectedEObject, newValue, oldValue)
}

routine routinePackageRenamed(umlclass::Package classPackage, String newName, String oldName) {
	action {
		call {
			//Check if Package rename is illegal
			//This is the case if it's the DataType package or gets its name, or if it has a corresponding Component
			//Renaming the Component is not possible as renaming the Class would be required too
			val comps = correspondenceModel.getCorrespondingEObjects(#[classPackage]).flatten.filter(Component)
			var Component comp = if(!comps.isEmpty) comps.get(0) else null		
			if ((oldName == CLASS_DATATYPES_PACKAGE_NAME) || (comp !== null) || (newName == CLASS_DATATYPES_PACKAGE_NAME)) {
				//TODO revert rename currently not possible
			}
			//TODO Therefore use temporary hack:
			if (oldName == CLASS_DATATYPES_PACKAGE_NAME)
				classPackage.name = CLASS_DATATYPES_PACKAGE_NAME
			else if ((newName == CLASS_DATATYPES_PACKAGE_NAME) && (oldName !== null)) {
				//Check for pre-exisitnce of the DataTypePackage:
				val dataTypePackageExistence = classPackage.model.packagedElements.filter(Package).filter[name==CLASS_DATATYPES_PACKAGE_NAME]
				if (!dataTypePackageExistence.isEmpty) 
					classPackage.name = "DefaultPackageName"
			}
				
		}
	}
}

reaction PackageDeleted {
	after element umlclass::Package deleted and removed from umlclass::Model[packagedElement]
	call routinePackageDeleted(oldValue, affectedEObject)
}

routine routinePackageDeleted(umlclass::Package classPackage, umlclass::Model classModel) {
	action {
		call {
			//Check if Package removal is illegal
			//This is the case if it's the DataType package or if it has a corresponding Component
			val comps = correspondenceModel.getCorrespondingEObjects(#[classPackage]).flatten.filter(Component)
			var Component comp = if(!comps.isEmpty) comps.get(0) else null		
			if ((classPackage.name == CLASS_DATATYPES_PACKAGE_NAME) || (comp !== null)) {
				//TODO revert remove currently not possible
			}			
		}
	}
}

/***********
*Visibility:*
************/

reaction ElementVisibilityChanged {
	after attribute replaced at umlclass::NamedElement[visibility]
	call changeCorrespondingVisibility(affectedEObject)
}

routine changeCorrespondingVisibility(umlclass::NamedElement classElement) {
	action {
		call {
			val correspondingElements = correspondenceModel.getCorrespondingEObjects(#[classElement]).flatten
			for (EObject compElement : correspondingElements) {
				(compElement as NamedElement).visibility = classElement.visibility
			}
		}
	}
}


/************
*Interfaces:*
*************/

//TODO: implement correctly
reaction CreatedInterface {
	after element umlclass::Interface created and inserted in umlclass::Package[packagedElement]
	call createInterface(newValue)
}

routine createInterface(umlclass::Interface classInterface) {
	action {
		val compInterface = create umlcomp::Interface and initialize {
			compInterface.name = classInterface.name
		}
		add correspondence between classInterface and compInterface
	}
}


//***Provided***

reaction InterfaceRealized{
	after element umlclass::Interface created and inserted in umlclass::Class[interfaceRealization] //TODO fix this, different element/set
	call createInterfaceRealization(affectedEObject, newValue)
}

routine createInterfaceRealization(umlclass::Class umlClass, umlclass::Interface classInterface) {
	match {
		val umlComp = retrieve umlcomp::Component corresponding to umlClass
	}
	action {
		val interfaceRealization = create umlcomp::InterfaceRealization and initialize {
			interfaceRealization.name = classInterface.name
			interfaceRealization.clients += umlComp
			interfaceRealization.suppliers += classInterface
		}
		update umlComp {
			umlComp.interfaceRealizations += interfaceRealization
		}
		add correspondence between interfaceRealization and classInterface
	}
	
}


//TODO ?? merge with required?
reaction InterfaceDeleted {
	after element removed from umlclass::Class[interfaceRealization]
	call deleteInterfaceRealization(oldValue)
}
routine deleteInterfaceRealization(umlclass::InterfaceRealization classInterface) {
	match {
		val interfaceRealization = retrieve umlcomp::InterfaceRealization corresponding to classInterface
	}
	action {
		delete interfaceRealization
	}
}

//***Required***

reaction AddedUsesRelationship {
	after element umlclass::Interface created and inserted in umlclass::Class[useCase] //TODO useCase correct??
	call addRequiredRole(affectedEObject, newValue)
}

routine addRequiredRole(umlclass::Class umlClass, umlclass::Interface classInterface) {
	match {
		val umlComp = retrieve umlcomp::Component corresponding to umlClass
	}
	action {
		val usage = create umlcomp::Usage and initialize {
			usage.name = classInterface.name
			usage.clients += umlComp
			usage.suppliers += classInterface
		}
		update umlComp {
			umlComp.packagedElements += usage
		}
		add correspondence between usage and classInterface
	}
}


