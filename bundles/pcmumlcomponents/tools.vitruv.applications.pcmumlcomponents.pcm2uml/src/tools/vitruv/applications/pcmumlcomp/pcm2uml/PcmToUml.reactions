import tools.vitruv.applications.pcmumlcomp.pcm2uml.PcmToUmlUtil
import org.eclipse.emf.common.util.URI
import org.eclipse.uml2.uml.resource.UMLResource
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.palladiosimulator.pcm.repository.CollectionDataType
import org.palladiosimulator.pcm.repository.PrimitiveDataType
import org.eclipse.emf.ecore.util.EcoreUtil
import org.palladiosimulator.pcm.repository.OperationSignature
import org.palladiosimulator.pcm.repository.InnerDeclaration
import org.palladiosimulator.pcm.repository.Parameter
import tools.vitruv.framework.userinteraction.UserInteractionType

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml
import "http://palladiosimulator.org/PalladioComponentModel/5.1" as pcm

reactions: PcmToUml
in reaction to changes in PCM
execute actions in UML


// ###################################################
// ############### UNIVERSAL REACTIONS ###############

reaction RenamedElement {
	after attribute replaced at pcm::NamedElement[entityName]
	call renameUmlElement(affectedEObject)
}

routine renameUmlElement(pcm::NamedElement pcmElement) {
	match {
		val umlElement = retrieve uml::NamedElement corresponding to pcmElement 
	}
	action {
		update umlElement {
			umlElement.name = pcmElement.entityName
		}
	}
}

// most elements should be named. others might get special treatment
routine deleteElement(pcm::NamedElement pcmElement) {
	match {
		val umlElement = retrieve uml::NamedElement corresponding to pcmElement
	}
	action {
		delete umlElement
	}
}

// ###################################################
// ############### CONTAINER REACTIONS ###############

reaction CreatedPcmRepository {
	after element pcm::Repository created and inserted as root
	call createUmlModel(newValue)
}

routine createUmlModel(pcm::Repository pcmRepository) {
	action {
		val packageImport = create uml::PackageImport and initialize {
			val resourceSet = new ResourceSetImpl()
			val primitiveTypesUri = URI.createURI(UMLResource.UML_PRIMITIVE_TYPES_LIBRARY_URI).appendFragment("_0")
			val primitiveTypes = resourceSet.getEObject(primitiveTypesUri, true)
			packageImport.importedPackage = primitiveTypes as org.eclipse.uml2.uml.Package
		}
		val umlModel = create uml::Model and initialize {
			umlModel.name = pcmRepository.entityName
			umlModel.packageImports += packageImport
			persistProjectRelative(pcmRepository, umlModel, "model/" + pcmRepository.entityName + ".uml")	
		}
		add correspondence between pcmRepository and umlModel
	}
}


// ###################################################
// ############## DATA TYPES REACTIONS ###############

reaction CreatedPrimitiveDataType {
	after element pcm::PrimitiveDataType created and inserted in pcm::Repository[dataTypes__Repository]
	call createPrimitiveDataType(newValue)
}

routine createPrimitiveDataType(pcm::PrimitiveDataType dataType) {
	match {
		val umlModel = retrieve uml::Model corresponding to dataType.repository__DataType
	}
	action {
		val umlType = create uml::PrimitiveType and initialize {
			umlType.name = PcmToUmlUtil.getUmlPrimitiveTypeName(dataType.type)
		}
		update umlModel {
			umlModel.ownedTypes += umlType
		}
		add correspondence between dataType and umlType
	}
}

reaction DeletedDataType {
	after element pcm::DataType deleted and removed from pcm::Repository[dataTypes__Repository]
	call deleteDataType(oldValue)
}

routine deleteDataType(pcm::DataType dataType) {
	match {
		val umlType = retrieve uml::Type corresponding to dataType
	}
	action {
		delete umlType
	}
}

reaction CreatedCompositeDataType {
	after element pcm::CompositeDataType created and inserted in pcm::Repository[dataTypes__Repository]
	call createCompositeDataType(newValue)
}

routine createCompositeDataType(pcm::CompositeDataType dataType) {
	match {
		val umlModel = retrieve uml::Model corresponding to dataType.repository__DataType
	}
	action {
		val umlType = create uml::DataType and initialize {
			umlType.name = dataType.entityName
		}
		update umlModel {
			umlModel.ownedTypes += umlType
		}
		add correspondence between dataType and umlType
	}
}

reaction CreatedInnerDeclaration {
	after element pcm::InnerDeclaration created and inserted in pcm::CompositeDataType[innerDeclaration_CompositeDataType]
	call createInnerDeclaration(newValue)
}

routine createInnerDeclaration(pcm::InnerDeclaration innerDeclaration) {
	match {
		val compositeType = retrieve uml::DataType corresponding to innerDeclaration.compositeDataType_InnerDeclaration
		val umlType = retrieve optional uml::DataType corresponding to innerDeclaration.datatype_InnerDeclaration
	}
	action {
		call createUmlPropertyForDatatype(umlType, innerDeclaration, compositeType)
	}
}

reaction ChangedInnerDeclarationType {
	after element replaced at pcm::InnerDeclaration[datatype_InnerDeclaration]
	call changeInnerDeclarationType(affectedEObject, newValue)
}

routine changeInnerDeclarationType(pcm::InnerDeclaration innerDeclaration, pcm::DataType pcmDataType) {
	match {
		val umlProperty = retrieve uml::Property corresponding to innerDeclaration
		val umlType = retrieve optional uml::DataType corresponding to pcmDataType
	}
	action {
		update umlProperty {
			if (pcmDataType === null) {
				umlProperty.type = null
			} else {
				if (umlType === null) {
					umlProperty.type = PcmToUmlUtil.retrieveUmlType(correspondenceModel, pcmDataType)
				} else {
					umlProperty.type = umlType
				}
				PcmToUmlUtil.updateMultiplicity(umlProperty, pcmDataType instanceof CollectionDataType)
			}
		}
	}
}

reaction DeletedInnerDeclaration {
	after element pcm::InnerDeclaration removed from pcm::CompositeDataType[innerDeclaration_CompositeDataType]
	call deleteInnerDeclaration(affectedEObject, oldValue)
}

routine deleteInnerDeclaration(pcm::CompositeDataType dataType, pcm::InnerDeclaration innerDeclaration) {
	match {
		val compositeType = retrieve uml::DataType corresponding to dataType
		val umlProperty = retrieve uml::Property corresponding to innerDeclaration
	}
	action {
		call compositeType.ownedAttributes.remove(umlProperty)
	}
}

reaction AddedCompositeDataTypeParent {
	after element inserted in pcm::CompositeDataType[parentType_CompositeDataType]
	call addCompositeDataTypeParent(affectedEObject, newValue)
}

routine addCompositeDataTypeParent(pcm::CompositeDataType dataType, pcm::CompositeDataType parent) {
	match {
		val compositeType = retrieve uml::DataType corresponding to dataType
		val parentType = retrieve uml::DataType corresponding to parent
	}
	action {
		val generalization = create uml::Generalization and initialize {
			generalization.general = parentType
			generalization.specific = compositeType
		}
		update compositeType {
			compositeType.generalizations += generalization
		}
	}
}

reaction RemovedCompositeDataTypeParent {
	after element removed from pcm::CompositeDataType[parentType_CompositeDataType]
	call removeCompositeDataTypeParent(affectedEObject, oldValue)
}

routine removeCompositeDataTypeParent(pcm::CompositeDataType dataType, pcm::CompositeDataType parent) {
	match {
		val compositeType = retrieve uml::DataType corresponding to dataType
		val parentType = retrieve uml::DataType corresponding to parent
	}
	action {
		update compositeType {
			compositeType.parents -= parentType
		}
	}
}

reaction ChangedCollectionDataTypeInnerType {
	after element replaced at pcm::CollectionDataType[innerType_CollectionDataType]
	call createCollectionDataTypeInnerType(affectedEObject, newValue)
}

routine createCollectionDataTypeInnerType(pcm::CollectionDataType pcmDataType, pcm::DataType pcmInnerType) {
	match {
		val umlInnerType = retrieve optional uml::DataType corresponding to pcmInnerType
	}
	action {
		call {
			if (pcmInnerType instanceof CollectionDataType) {
				userInteracting.showMessage(UserInteractionType.MODAL,
					"Nested collection types are not transformed to UML. Consider using a composite type.")
			} else {
				var innerType = umlInnerType
				if (innerType === null) {
					innerType = PcmToUmlUtil.retrieveUmlType(correspondenceModel, pcmInnerType)
				}
				if (innerType === null) {
					logger.info("collection type: " + pcmDataType.entityName)
					logger.info(pcmInnerType)
					logger.info((pcmInnerType as PrimitiveDataType).type)
					logger.info(innerType)
					clearCorrespondenceForCollectionTypes(pcmDataType)
					addCorrespondenceForCollectionTypes(pcmDataType, innerType)
					val references = EcoreUtil.UsageCrossReferencer.find(pcmDataType, pcmDataType.repository__DataType)
					for (reference : references) {
						if (reference.EObject instanceof OperationSignature && reference.EStructuralFeature.name == "returnType__OperationSignature") {
							changeUmlOperationType(reference.EObject as OperationSignature)
						} else if (reference.EObject instanceof InnerDeclaration && reference.EStructuralFeature.name == "datatype_InnerDeclaration") {
							changeInnerDeclarationType(reference.EObject as InnerDeclaration, pcmInnerType)
						} else if (reference.EObject instanceof Parameter && reference.EStructuralFeature.name == "dataType__Parameter") {
							changeParameterType(reference.EObject as Parameter, pcmInnerType)
						} else {
							logger.warn("Inner collection type changed at unhandled reference for " + reference.EObject.class.name +
								" at " + reference.EStructuralFeature.name)
						}
						logger.info("reference for collection type: ")
						logger.info(reference.EObject)
						logger.info(reference.EStructuralFeature)
					}
				} else {
					logger.warn("CollectionDataType inner type could not be resolved")
				}
			}
		}
	}
}

reaction RemovedCollectionDataTypeInnerType {
	after element removed from pcm::CollectionDataType[innerType_CollectionDataType]
	call removeCollectionDataTypeInnerType(affectedEObject, oldValue)
}

routine removeCollectionDataTypeInnerType(pcm::CollectionDataType pcmDataType, pcm::DataType pcmInnerType) {
	match {
		val umlInnerType = retrieve uml::DataType corresponding to pcmInnerType
	}
	action {
		call PcmToUmlUtil.unsetTypeOccurences(pcmDataType)
	}
}

routine clearCorrespondenceForCollectionTypes(pcm::CollectionDataType pcmType) {
	match {
		val oldInnerType = retrieve uml::DataType corresponding to pcmType tagged with "collectionType"
	}
	action {
		call println("cleared correspondence between an inner type and a uml type")
		remove correspondence between pcmType and oldInnerType
	}
}
routine addCorrespondenceForCollectionTypes(pcm::CollectionDataType pcmType, uml::DataType innerType) {
	match {
		val oldInnerType = retrieve optional uml::DataType corresponding to pcmType tagged with "collectionType"
	}
	action {
		call println("created correspondence between an inner type and a uml type")
		add correspondence between pcmType and innerType tag with "collectionType"
	}
}

routine createUmlPropertyForDatatype(uml::DataType type, pcm::InnerDeclaration counterpart, uml::DataType owner) {
	action {
		val property = create uml::Property and initialize {
			property.name = counterpart.entityName
			property.type = type
		}
		update owner {
			owner.ownedAttributes += property
		}
		add correspondence between counterpart and property
	}
}


// ###################################################
// ############## INTERFACE REACTIONS ################

reaction CreatedPcmInterface {
	after element created and inserted in pcm::Repository[interfaces__Repository]
	call createUmlInterface(newValue)
}

routine createUmlInterface(pcm::Interface pcmInterface) {
	match {
		val umlModel = retrieve uml::Model corresponding to pcmInterface.repository__Interface 
	}
	action { 
		val umlInterface = create uml::Interface and initialize {
			umlInterface.name = pcmInterface.entityName
		}
		update umlModel {
			umlModel.packagedElements += umlInterface
		}
		add correspondence between umlInterface and pcmInterface
	}
}

reaction DeletedPcmInterface {
	after element removed from pcm::Repository[interfaces__Repository]
	call deleteElement(oldValue)
}

reaction CreatedOperationInterfaceSignature {
	after element created and inserted in pcm::OperationInterface[signatures__OperationInterface]
	call createOperationInterfaceSignature(newValue)
}

routine createOperationInterfaceSignature(pcm::OperationSignature pcmSignature) {
	match {
		val umlInterface = retrieve uml::Interface corresponding to pcmSignature.interface__OperationSignature
	}
	action {
		val umlOperation = create uml::Operation and initialize {
			umlOperation.name = pcmSignature.entityName
		}
		update umlInterface {
			umlInterface.ownedOperations += umlOperation
		}
		add correspondence between umlOperation and pcmSignature
	}
}

reaction ChangedOperationSignatureType {
	after element replaced at pcm::OperationSignature[returnType__OperationSignature]
	call {
		if (newValue === null) {
			unsetUmlOperationType(affectedEObject)
		} else {
			changeUmlOperationType(affectedEObject)
		}
	}
}

routine changeUmlOperationType(pcm::OperationSignature pcmSignature) {
	match {
		val umlOperation = retrieve uml::Operation corresponding to pcmSignature
		val umlReturnType = retrieve optional uml::DataType corresponding to pcmSignature.returnType__OperationSignature
	}
	action {
		update umlOperation {
			var returnType = umlReturnType
			if (returnType === null) {
				if (pcmSignature.returnType__OperationSignature instanceof PrimitiveDataType) {
					println("> is primitive type")
					returnType = PcmToUmlUtil.getUmlPrimitiveType((pcmSignature.returnType__OperationSignature as PrimitiveDataType).type)
					println(returnType)
				} else if (pcmSignature.returnType__OperationSignature instanceof CollectionDataType) {
					val innerType = pcmSignature.returnType__OperationSignature
					if (innerType instanceof PrimitiveDataType) {
						println("> innerType is primitive type")
						returnType = PcmToUmlUtil.getUmlPrimitiveType(innerType.type)
						println(returnType)
					}
				} else {
					println("> is not primitive")
					println(pcmSignature.returnType__OperationSignature)
				}
			}
			umlOperation.type = returnType
			PcmToUmlUtil.updateOperationReturnTypeMultiplicity(
				umlOperation,
				pcmSignature.returnType__OperationSignature instanceof CollectionDataType
				)
		}
	}
}

routine unsetUmlOperationType(pcm::OperationSignature pcmSignature) {
	match {
		val umlOperation = retrieve uml::Operation corresponding to pcmSignature
	}
	action {
		update umlOperation {
			umlOperation.type = null
		}
	}
}

reaction DeletedOperationInterfaceSignature {
	after element removed from pcm::OperationInterface[signatures__OperationInterface]
	call deleteElement(oldValue) 
}

reaction CreatedOperationSignatureParameter {
	after element inserted in pcm::OperationSignature[parameters__OperationSignature]
	call createOperationSignatureParameter(affectedEObject, newValue)
}
routine createOperationSignatureParameter(pcm::OperationSignature pcmSignature, pcm::Parameter pcmParameter)
{
	match {
		val umlOperation = retrieve uml::Operation corresponding to pcmSignature
	}
	action {
		val umlParameter = create uml::Parameter and initialize {
			umlParameter.name = pcmParameter.entityName
		}
		update umlOperation {
			umlOperation.ownedParameters += umlParameter
		}
		add correspondence between umlParameter and pcmParameter
	}
}
reaction RenamedParameter {
	after attribute replaced at pcm::Parameter[parameterName]
	call renameParameter(affectedEObject)
}
routine renameParameter(pcm::Parameter pcmParameter) {
	match {
		val umlParameter = retrieve uml::Parameter corresponding to pcmParameter
	}
	action {
		update umlParameter {
			umlParameter.name = pcmParameter.parameterName
		}
	}
}
reaction ChangedParameterDirection {
	after attribute replaced at pcm::Parameter[modifier__Parameter]
	call changeParameterDirection(affectedEObject)
}
routine changeParameterDirection(pcm::Parameter pcmParameter) {
	match {
		val umlParameter = retrieve uml::Parameter corresponding to pcmParameter
	}
	action {
		update umlParameter {
			umlParameter.direction = PcmToUmlUtil.getUmlParameterDirection(pcmParameter.modifier__Parameter)
		}
	}
}
reaction ChangedParameterType {
	after element pcm::DataType replaced at pcm::Parameter[dataType__Parameter]
	call changeParameterType(affectedEObject, newValue)
}
routine changeParameterType(pcm::Parameter pcmParameter, pcm::DataType pcmDataType) {
	match {
		val umlParameter = retrieve uml::Parameter corresponding to pcmParameter
		// val umlType = retrieve optional uml::DataType corresponding to pcmParameter.dataType__Parameter
	}
	action {
		update umlParameter {
			logger.info("Change Parameter type at " + pcmParameter.parameterName + ", " + pcmParameter.operationSignature__Parameter.entityName + " to " + pcmDataType)
			umlParameter.type = PcmToUmlUtil.retrieveUmlType(correspondenceModel, pcmDataType)
			PcmToUmlUtil.updateMultiplicity(umlParameter, pcmDataType instanceof CollectionDataType)
		}
	}
}
reaction DeletedOperationSignatureParameter {
	after element pcm::Parameter removed from pcm::OperationSignature[parameters__OperationSignature]
	call removeOperationSignatureParameter(oldValue)
}
routine removeOperationSignatureParameter(pcm::Parameter pcmParameter) {
	match {
		val umlParameter = retrieve uml::Parameter corresponding to pcmParameter
	}
	action {
		delete umlParameter
	}
}

// ###################################################
// ############### COMPONENT REACTIONS ###############

reaction CreatedBasicPcmComponent {
	after element pcm::BasicComponent created and inserted in pcm::Repository[components__Repository]
	call createUmlComponent(newValue, "basic")
}
reaction CreatedCompositePcmComponent {
	after element pcm::CompositeComponent created and inserted in pcm::Repository[components__Repository]
	call createUmlComponent(newValue, "composite")
}
routine createUmlComponent(pcm::RepositoryComponent pcmComponent, String correspondenceTag) {
	match {
		val umlModel = retrieve uml::Model corresponding to pcmComponent.repository__RepositoryComponent 
	}
	action {
		val umlComponent = create uml::Component and initialize {
			umlComponent.name = pcmComponent.entityName;
		}
		update umlModel {
			umlModel.packagedElements += umlComponent;
		}
		add correspondence between pcmComponent and umlComponent tag with correspondenceTag
	}
}
reaction DeletedComponent {
	after element removed from pcm::Repository[components__Repository]
	call deleteElement(oldValue)
}

reaction CreatedProvidedRole {
	after element created and inserted in pcm::InterfaceProvidingEntity[providedRoles_InterfaceProvidingEntity]
	call createProvidedRole(affectedEObject, newValue)
}
routine createProvidedRole(pcm::InterfaceProvidingEntity pcmComponent, pcm::ProvidedRole pcmProvidedRole) {
	match {
		val umlComponent = retrieve uml::Component corresponding to pcmComponent
	}
	action {
		val interfaceRealization = create uml::InterfaceRealization and initialize {
			interfaceRealization.name = pcmProvidedRole.entityName
			interfaceRealization.clients += umlComponent
		}
		update umlComponent {
			umlComponent.interfaceRealizations += interfaceRealization
		}
		add correspondence between interfaceRealization and pcmProvidedRole
	}
}
reaction DeletedProvidedRole {
	after element removed from pcm::InterfaceProvidingEntity[providedRoles_InterfaceProvidingEntity]
	call deleteProvidedRole(oldValue)
}
routine deleteProvidedRole(pcm::ProvidedRole pcmProvidedRole) {
	match {
		val interfaceRealization = retrieve uml::InterfaceRealization corresponding to pcmProvidedRole
	}
	action {
		delete interfaceRealization
	}
}
reaction AddedOperationProvidedRoleInterface {
	after element replaced at pcm::OperationProvidedRole[providedInterface__OperationProvidedRole]
	call addOperationProvidedRoleInterface(affectedEObject, newValue)
}
// TODO: interface is not created at this point
routine addOperationProvidedRoleInterface(pcm::OperationProvidedRole pcmRole, pcm::OperationInterface pcmInterface) {
	match {
		val interfaceRealization = retrieve uml::InterfaceRealization corresponding to pcmRole
		val umlInterface = retrieve uml::Interface corresponding to pcmInterface
		val umlComponent = retrieve uml::Component corresponding to pcmRole.providingEntity_ProvidedRole
	}
	action {
		update interfaceRealization {
			interfaceRealization.suppliers.clear()
			interfaceRealization.suppliers += umlInterface
		}
	}
}

reaction CreatedRequiredRole {
	after element pcm::OperationRequiredRole inserted in pcm::InterfaceRequiringEntity[requiredRoles_InterfaceRequiringEntity]
	call createRequiredRole(affectedEObject, newValue)
}
routine createRequiredRole(pcm::InterfaceRequiringEntity pcmComponent, pcm::OperationRequiredRole requiredRole) {
	match {
		val umlComponent = retrieve uml::Component corresponding to pcmComponent
	}
	action {
		val usage = create uml::Usage and initialize {
			usage.name = requiredRole.entityName
			usage.clients += umlComponent
		}
		update umlComponent {
			umlComponent.packagedElements += usage
		}
		add correspondence between usage and requiredRole
	}
}
reaction DeletedRequiredRole {
	after element pcm::OperationRequiredRole removed from pcm::InterfaceRequiringEntity[requiredRoles_InterfaceRequiringEntity]
	call deleteRequiredRole(oldValue)
}
routine deleteRequiredRole(pcm::OperationRequiredRole requiredRole) {
	match {
		val usage = retrieve uml::Usage corresponding to requiredRole
	}
	action {
		delete usage
	}
}
reaction AddedOperationRequiredRoleInterface {
	after element replaced at pcm::OperationRequiredRole[requiredInterface__OperationRequiredRole]
	call addOperationRequiredRoleInterface(affectedEObject, newValue)
}
routine addOperationRequiredRoleInterface(pcm::OperationRequiredRole pcmRole, pcm::OperationInterface pcmInterface) {
	match {
		val umlUsage = retrieve uml::Usage corresponding to pcmRole
		val umlInterface = retrieve uml::Interface corresponding to pcmInterface
	}
	action {
		update umlUsage {
			umlUsage.suppliers.clear()
			umlUsage.suppliers += umlInterface
		}
	}
}
