import org.palladiosimulator.pcm.repository.PrimitiveDataType
import tools.vitruv.aplications.pcmumlcomp.pcm2uml.PcmToUmlUtil
import org.palladiosimulator.pcm.repository.BasicComponent

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml
import "http://palladiosimulator.org/PalladioComponentModel/5.1" as pcm

reactions: PcmToUml
in reaction to changes in pcm
execute actions in uml


// ###################################################
// ############### UNIVERSAL REACTIONS ###############

reaction RenamedElement {
	after attribute replaced at pcm::NamedElement[entityName] //with
		//!(affectedEObject instanceof PrimitiveDataType)
	call renameUmlElement(affectedEObject)
}

routine renameUmlElement(pcm::NamedElement pcmElement) {
	match {
		val umlElement = retrieve uml::NamedElement corresponding to pcmElement 
	}
	action {
		update umlElement {
			umlElement.name = pcmElement.entityName
		}
	}
}

// most elements should be named. others might get special treatment
routine deleteElement(pcm::NamedElement pcmElement) {
	match {
		val umlElement = retrieve uml::NamedElement corresponding to pcmElement
	}
	action {
		delete umlElement
	}
}

// ###################################################
// ############### CONTAINER REACTIONS ###############

reaction CreatedPcmRepository {
	after element pcm::Repository created and inserted as root
	call createUmlModel(newValue)
}

routine createUmlModel(pcm::Repository pcmRepository) {
	action {
		val umlModel = create uml::Model and initialize {
			umlModel.name = pcmRepository.entityName;
			persistProjectRelative(pcmRepository, umlModel, "model/" + pcmRepository.entityName + ".uml")	
		}
		add correspondence between pcmRepository and umlModel
	}
}


// ###################################################
// ############## DATA TYPES REACTIONS ###############

reaction CreatedPrimitiveDataType {
	after element pcm::PrimitiveDataType created and inserted in pcm::Repository[dataTypes__Repository]
	call createPrimitiveDataType(newValue)
}

routine createPrimitiveDataType(pcm::PrimitiveDataType dataType) {
	match {
		val umlModel = retrieve uml::Model corresponding to dataType.repository__DataType
	}
	action {
		val umlType = create uml::PrimitiveType and initialize {
			umlType.name = PcmToUmlUtil.getUmlPrimitiveType(dataType.type)
		}
		update umlModel {
			umlModel.ownedTypes += umlType
		}
		add correspondence between dataType and umlType
	}
}

reaction DeletedDataType {
	after element pcm::DataType deleted and removed from pcm::Repository[dataTypes__Repository]
	call deleteDataType(oldValue)
}

routine deleteDataType(pcm::DataType dataType) {
	match {
		// val umlModel = retrieve uml::Model corresponding to dataType.repository__DataType
		val umlType = retrieve uml::Type corresponding to dataType
	}
	action {
		delete umlType
	}
}

reaction CreatedCompositeDataType {
	after element pcm::CompositeDataType created and inserted in pcm::Repository[dataTypes__Repository]
	call createCompositeDataType(newValue)
}

routine createCompositeDataType(pcm::CompositeDataType dataType) {
	match {
		val umlModel = retrieve uml::Model corresponding to dataType.repository__DataType
	}
	action {
		val umlType = create uml::DataType and initialize {
			umlType.name = dataType.entityName
		}
		update umlModel {
			umlModel.ownedTypes += umlType
		}
		add correspondence between dataType and umlType
	}
}

reaction CreatedInnerDeclaration {
	after element pcm::InnerDeclaration created and inserted in pcm::CompositeDataType[innerDeclaration_CompositeDataType]
	call createInnerDeclaration(newValue)
}

routine createInnerDeclaration(pcm::InnerDeclaration innerDeclaration) {
	match {
		val compositeType = retrieve uml::DataType corresponding to innerDeclaration.compositeDataType_InnerDeclaration
		val umlType = retrieve uml::DataType corresponding to innerDeclaration.datatype_InnerDeclaration
	}
	action {
		call createUmlPropertyForDatatype(umlType, innerDeclaration, compositeType)
	}
}

reaction DeletedInnerDeclaration {
	after element pcm::InnerDeclaration removed from pcm::CompositeDataType[innerDeclaration_CompositeDataType]
	call deleteInnerDeclaration(affectedEObject, oldValue)
}

routine deleteInnerDeclaration(pcm::CompositeDataType dataType, pcm::InnerDeclaration innerDeclaration) {
	match {
		val compositeType = retrieve uml::DataType corresponding to dataType
		val umlProperty = retrieve uml::Property corresponding to innerDeclaration
	}
	action {
		call compositeType.ownedAttributes.remove(umlProperty)
	}
}

/*reaction RenamedInnerDeclaration {
	after attribute replaced at pcm::InnerDeclaration[entityName]
	call renameInnerDeclaration(affectedEObject)
}

routine renameInnerDeclaration(pcm::InnerDeclaration innerDeclaration) {
	match {
		val umlType = retrieve uml::DataType corresponding to innerDeclaration.compositeDataType_InnerDeclaration
	}
	action {
		call renameUmlProperty(innerDeclaration)
	}
}*/

reaction CreatedCollectionDataType {
	after element pcm::CollectionDataType created and inserted in  pcm::Repository[dataTypes__Repository]
	call createCollectionDataType(newValue)
}

routine createCollectionDataType(pcm::CollectionDataType dataType) {
	match {
		val umlModel = retrieve uml::Model corresponding to dataType.repository__DataType
		//val umlInnerType = retrieve uml::DataType corresponding to dataType.innerType_CollectionDataType
	}
	action {
		//val umlProperty = create uml::Property and initialize {
			//umlProperty.type = umlInnerType
			//umlProperty.name = "innerType"
			// TODO: no correspondence for property = NPE?
		//}
		val umlType = create uml::DataType and initialize {
			umlType.name = dataType.entityName
			// umlType.ownedAttributes += umlProperty
		}
		update umlModel {
			umlModel.ownedTypes += umlType
			// TODO: packagesElements had to be used from the UML side?
			umlModel.packagedElements += umlType
		}
		add correspondence between dataType and umlType
	}
}

reaction CreatedCollectionDataTypeType {
	after element inserted in pcm::CollectionDataType[innerType_CollectionDataType]
	call {
		System.out.println("[created collection datatype type]")
		createCollectionDataTypeType(affectedEObject, newValue)
		}
}

routine createCollectionDataTypeType(pcm::CollectionDataType pcmDataType, pcm::DataType pcmInnerType) {
	match {
		val umlType = retrieve uml::DataType corresponding to pcmDataType
		val umlInnerType =  retrieve uml::DataType corresponding to pcmInnerType
	}
	action {
		val umlProperty = create uml::Property and initialize {
			umlProperty.name = PcmToUmlUtil.CollectionTypeAttributeName
			umlProperty.type = umlInnerType
		}
		update umlType {
			umlType.ownedAttributes += umlProperty
		}
	}
}

reaction ChangedCollectionDataTypeType {
	after element replaced at pcm::CollectionDataType[innerType_CollectionDataType]
	call changeCollectionDataTypeType(affectedEObject, newValue)
}

routine changeCollectionDataTypeType(pcm::CollectionDataType pcmDataType, pcm::DataType pcmInnerType) {
	match {
		val umlType = retrieve uml::DataType corresponding to pcmDataType
		val umlInnerType =  retrieve uml::DataType corresponding to pcmInnerType
	}
	action {
		call PcmToUmlUtil.changeCollectionDataTypeReturnType(umlType, umlInnerType)
	}
}

routine createUmlPropertyForDatatype(uml::DataType type, pcm::InnerDeclaration counterpart, uml::DataType owner) {
	action {
		val property = create uml::Property and initialize {
			property.name = counterpart.entityName
			property.type = type
		}
		update owner {
			owner.ownedAttributes += property
		}
		add correspondence between counterpart and property
	}
}


// ###################################################
// ############## INTERFACE REACTIONS ################

reaction CreatedPcmInterface {
	after element created and inserted in pcm::Repository[interfaces__Repository]
	call createUmlInterface(newValue)
}

routine createUmlInterface(pcm::Interface pcmInterface) {
	match {
		val umlModel = retrieve uml::Model corresponding to pcmInterface.repository__Interface 
	}
	action {
		val umlInterface = create uml::Interface and initialize {
			umlInterface.name = pcmInterface.entityName
		}
		update umlModel {
			umlModel.packagedElements += umlInterface
		}
		add correspondence between umlInterface and pcmInterface
	}
}

reaction DeletedPcmInterface {
	after element removed from pcm::Repository[interfaces__Repository]
	call deleteElement(oldValue)
}

reaction CreatedOperationInterfaceSignature {
	after element created and inserted in pcm::OperationInterface[signatures__OperationInterface]
	call createOperationInterfaceSignature(newValue)
}

routine createOperationInterfaceSignature(pcm::OperationSignature pcmSignature) {
	match {
		val umlInterface = retrieve uml::Interface corresponding to pcmSignature.interface__OperationSignature
	}
	action {
		val umlOperation = create uml::Operation and initialize {
			umlOperation.name = pcmSignature.entityName
		}
		update umlInterface {
			umlInterface.ownedOperations += umlOperation
		}
		add correspondence between umlOperation and pcmSignature
	}
}

reaction ChangedOperationSignatureType {
	after element replaced at pcm::OperationSignature[returnType__OperationSignature]
	call {
		if (newValue === null)
			unsetUmlOperationType(affectedEObject)
		else
			changeUmlOperationType(affectedEObject)
	}
}
routine changeUmlOperationType(pcm::OperationSignature pcmSignature) {
	match {
		val umlOperation = retrieve uml::Operation corresponding to pcmSignature
		val umlReturnType = retrieve uml::DataType corresponding to pcmSignature.returnType__OperationSignature
	}
	action {
		update umlOperation {
			umlOperation.type = umlReturnType
		}
	}
}
routine unsetUmlOperationType(pcm::OperationSignature pcmSignature) {
	match {
		val umlOperation = retrieve uml::Operation corresponding to pcmSignature
	}
	action {
		update umlOperation {
			umlOperation.type = null
		}
	}
}

reaction DeletedOperationInterfaceSignature {
	after element removed from pcm::OperationInterface[signatures__OperationInterface]
	call deleteElement(oldValue) 
}

reaction CreatedOperationSignatureParameter {
	after element inserted in pcm::OperationSignature[parameters__OperationSignature]
	call createOperationSignatureParameter(affectedEObject, newValue)
}
routine createOperationSignatureParameter(pcm::OperationSignature pcmSignature, pcm::Parameter pcmParameter)
{
	match {
		val umlOperation = retrieve uml::Operation corresponding to pcmSignature
	}
	action {
		val umlParameter = create uml::Parameter and initialize {
			umlParameter.name = pcmParameter.entityName
		}
		update umlOperation {
			umlOperation.ownedParameters += umlParameter
		}
		add correspondence between umlParameter and pcmParameter
	}
}
reaction RenamedParameter {
	after attribute replaced at pcm::Parameter[parameterName]
	call renameParameter(affectedEObject)
}
routine renameParameter(pcm::Parameter pcmParameter) {
	match {
		val umlParameter = retrieve uml::Parameter corresponding to pcmParameter
	}
	action {
		update umlParameter {
			umlParameter.name = pcmParameter.parameterName
		}
	}
}
reaction ChangedParameterDirection {
	after attribute replaced at pcm::Parameter[modifier__Parameter]
	call changeParameterDirection(affectedEObject)
}
routine changeParameterDirection(pcm::Parameter pcmParameter) {
	match {
		val umlParameter = retrieve uml::Parameter corresponding to pcmParameter
	}
	action {
		update umlParameter {
			umlParameter.direction = PcmToUmlUtil.getUmlParameterDirection(pcmParameter.modifier__Parameter)
		}
	}
}
reaction ChangedParameterType {
	after element pcm::DataType replaced at pcm::Parameter[dataType__Parameter]
	call changeParameterType(affectedEObject)
}
routine changeParameterType(pcm::Parameter pcmParameter) {
	match {
		val umlParameter = retrieve uml::Parameter corresponding to pcmParameter
		val umlType = retrieve uml::DataType corresponding to pcmParameter.dataType__Parameter
	}
	action {
		update umlParameter {
			umlParameter.type = umlType
		}
	}
}
reaction DeletedOperationSignatureParameter {
	after element pcm::Parameter removed from pcm::OperationSignature[parameters__OperationSignature]
	call removeOperationSignatureParameter(oldValue)
}
routine removeOperationSignatureParameter(pcm::Parameter pcmParameter) {
	match {
		val umlParameter = retrieve uml::Parameter corresponding to pcmParameter
	}
	action {
		delete umlParameter
	}
}

// ###################################################
// ############### COMPONENT REACTIONS ###############

reaction CreatedBasicPcmComponent {
	after element pcm::BasicComponent created and inserted in pcm::Repository[components__Repository]
	call createUmlComponent(newValue, "basic")
}
reaction CreatedCompositePcmComponent {
	after element pcm::CompositeComponent created and inserted in pcm::Repository[components__Repository]
	call createUmlComponent(newValue, "composite")
}
routine createUmlComponent(pcm::RepositoryComponent pcmComponent, String correspondenceTag) {
	match {
		val umlModel = retrieve uml::Model corresponding to pcmComponent.repository__RepositoryComponent 
	}
	action {
		val umlComponent = create uml::Component and initialize {
			umlComponent.name = pcmComponent.entityName;
		}
		update umlModel {
			umlModel.packagedElements += umlComponent;
		}
		add correspondence between pcmComponent and umlComponent tag with correspondenceTag
	}
}
reaction DeletedComponent {
	after element removed from pcm::Repository[components__Repository]
	call deleteElement(oldValue)
}

reaction CreatedProvidedRole {
	after element created and inserted in pcm::InterfaceProvidingEntity[providedRoles_InterfaceProvidingEntity]
	call createProvidedRole(affectedEObject, newValue)
}
routine createProvidedRole(pcm::InterfaceProvidingEntity pcmComponent, pcm::ProvidedRole pcmProvidedRole) {
	match {
		val umlComponent = retrieve uml::Component corresponding to pcmComponent
	}
	action {
		val interfaceRealization = create uml::InterfaceRealization and initialize {
			interfaceRealization.name = pcmProvidedRole.entityName
			interfaceRealization.clients += umlComponent
		}
		update umlComponent {
			umlComponent.interfaceRealizations += interfaceRealization
		}
		add correspondence between interfaceRealization and pcmProvidedRole
	}
}
reaction DeletedProvidedRole {
	after element removed from pcm::InterfaceProvidingEntity[providedRoles_InterfaceProvidingEntity]
	call deleteProvidedRole(oldValue)
}
routine deleteProvidedRole(pcm::ProvidedRole pcmProvidedRole) {
	match {
		val interfaceRealization = retrieve uml::InterfaceRealization corresponding to pcmProvidedRole
	}
	action {
		delete interfaceRealization
	}
}
reaction AddedOperationProvidedRoleInterface {
	after element replaced at pcm::OperationProvidedRole[providedInterface__OperationProvidedRole]
	call addOperationProvidedRoleInterface(affectedEObject, newValue)
}
routine addOperationProvidedRoleInterface(pcm::OperationProvidedRole pcmRole, pcm::OperationInterface pcmInterface) {
	match {
		val interfaceRealization = retrieve uml::InterfaceRealization corresponding to pcmRole
		val umlInterface = retrieve uml::Interface corresponding to pcmInterface
		val umlComponent = retrieve uml::Component corresponding to pcmRole.providingEntity_ProvidedRole
	}
	action {
		update interfaceRealization {
			interfaceRealization.suppliers.clear()
			interfaceRealization.suppliers += umlInterface
		}
	}
}

reaction CreatedRequiredRole {
	after element pcm::OperationRequiredRole inserted in pcm::InterfaceRequiringEntity[requiredRoles_InterfaceRequiringEntity]
	call createRequiredRole(affectedEObject, newValue)
}
routine createRequiredRole(pcm::InterfaceRequiringEntity pcmComponent, pcm::OperationRequiredRole requiredRole) {
	match {
		val umlComponent = retrieve uml::Component corresponding to pcmComponent
	}
	action {
		val usage = create uml::Usage and initialize {
			usage.name = requiredRole.entityName
			usage.clients += umlComponent
		}
		update umlComponent {
			umlComponent.packagedElements += usage
		}
		add correspondence between usage and requiredRole
	}
}
reaction DeletedRequiredRole {
	after element pcm::OperationRequiredRole removed from pcm::InterfaceRequiringEntity[requiredRoles_InterfaceRequiringEntity]
	call deleteRequiredRole(oldValue)
}
routine deleteRequiredRole(pcm::OperationRequiredRole requiredRole) {
	match {
		val usage = retrieve uml::Usage corresponding to requiredRole
	}
	action {
		delete usage
	}
}
reaction AddedOperationRequiredRoleInterface {
	after element replaced at pcm::OperationRequiredRole[requiredInterface__OperationRequiredRole]
	call addOperationRequiredRoleInterface(affectedEObject, newValue)
}
routine addOperationRequiredRoleInterface(pcm::OperationRequiredRole pcmRole, pcm::OperationInterface pcmInterface) {
	match {
		val umlUsage = retrieve uml::Usage corresponding to pcmRole
		val umlInterface = retrieve uml::Interface corresponding to pcmInterface
	}
	action {
		update umlUsage {
			umlUsage.suppliers.clear()
			umlUsage.suppliers += umlInterface
		}
	}
}
