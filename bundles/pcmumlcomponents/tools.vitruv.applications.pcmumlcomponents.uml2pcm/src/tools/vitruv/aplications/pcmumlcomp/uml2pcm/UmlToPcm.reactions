import org.eclipse.uml2.uml.DataType
import org.eclipse.uml2.uml.Operation
import org.eclipse.uml2.uml.Parameter
import org.eclipse.uml2.uml.ParameterDirectionKind
import org.eclipse.uml2.uml.PrimitiveType
import tools.vitruv.aplications.pcmumlcomp.uml2pcm.UmlToPcmUtil

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml
import "http://palladiosimulator.org/PalladioComponentModel/5.1" as pcm

reactions: UmlToPcm
in reaction to changes in uml
execute actions in pcm

// ###################################################
// ############### UNIVERSAL REACTIONS ###############

reaction RenamedElement {
	after attribute replaced at uml::NamedElement[name] with
		(!(affectedEObject instanceof Parameter))
	call renameElement(affectedEObject)
}

routine renameElement(uml::NamedElement umlElement) {
	match {
		val pcmElement = retrieve pcm::NamedElement corresponding to umlElement
	}
	action {
		update pcmElement {
			pcmElement.entityName = umlElement.name
		}
	}
}

reaction DeletedElement {
	after element removed from uml::Model[packagedElement]
	call deleteElement(oldValue)
}

routine deleteElement(uml::Element umlElement) {
	match {
		val pcmElement = retrieve pcm::Entity corresponding to umlElement
	}
	action {
		delete pcmElement
	}
}

// ###################################################
// ############### CONTAINER REACTIONS ###############

reaction CreatedUmlModel {
	after element uml::Model created and inserted as root
	call createPcmRepository(newValue)
}

routine createPcmRepository(uml::Model umlModel) {
	action {
		val pcmRepository = create pcm::Repository and initialize {
			pcmRepository.entityName = umlModel.name;
			persistProjectRelative(umlModel, pcmRepository, "repository/" + umlModel.name + ".repository")
		}
		add correspondence between umlModel and pcmRepository
	}
}

// ###################################################
// ############## DATA TYPES REACTIONS ###############

reaction CreatedPrimitiveDataType {
	after element uml::PrimitiveType created and inserted in uml::Model[packagedElement]
	call createPrimitiveDataType(newValue)
}

routine createPrimitiveDataType(uml::PrimitiveType umlType) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to umlType.model 
	}
	action {
		val pcmType = create pcm::PrimitiveDataType and initialize {
			pcmType.type = UmlToPcmUtil.getPcmPrimitiveType(umlType.name)
		}
		update pcmRepository {
			pcmRepository.dataTypes__Repository += pcmType
		}
		add correspondence between umlType and pcmType
	}
}

reaction CreatedDataType {
	after element uml::DataType created and inserted in uml::Model[packagedElement] with
		!(newValue instanceof PrimitiveType)
	call createDataType(newValue)
}

routine createDataType(uml::DataType umlType) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to umlType.model
	}
	action {
		val pcmType = create pcm::CompositeDataType and initialize {
			pcmType.entityName = umlType.name
		}
		update pcmRepository {
			pcmRepository.dataTypes__Repository += pcmType
		}
		add correspondence between umlType and pcmType
	}
}

reaction CreatedPropertyForDataType {
	after element uml::Property created and inserted in uml::DataType[ownedAttribute]
	call createInnerDeclarationOffProperty(newValue)
}

reaction ChangedPropertyOwnerForDataType {
	after element replaced at uml::Property[owner]
	call changeInnerDeclarationOwner(affectedEObject)
}

routine changeInnerDeclarationOwner(uml::Property umlProperty) {
	match {
		val pcmInnerDeclaration = retrieve pcm::InnerDeclaration corresponding to umlProperty
		val pcmOwner = retrieve pcm::CompositeDataType corresponding to umlProperty.owner
	}
	action {
		//update pcmInnerDeclaration.compositeDataType_InnerDeclaration {
		//	pcmInnerDeclaration.compositeDataType_InnerDeclaration.innerDeclaration_CompositeDataType -= pcmInnerDeclaration
		//}
		update pcmOwner {
			pcmOwner.innerDeclaration_CompositeDataType += pcmInnerDeclaration
		}
	}
}

routine createInnerDeclarationOffProperty(uml::Property property) {
	match {
		val pcmCompositeType = retrieve pcm::CompositeDataType corresponding to property.owner
	}
	action {
		val declaration = create pcm::InnerDeclaration and initialize {
			declaration.entityName = property.name
		}
		update pcmCompositeType {
			pcmCompositeType.innerDeclaration_CompositeDataType += declaration
		}
		add correspondence between property and declaration
	}
}

reaction ChangedPropertyType {
	after element replaced at uml::Property[type] with (newValue instanceof DataType)
	call changePropertyType(affectedEObject, (newValue as DataType))
}

routine changePropertyType(uml::Property umlProperty, uml::DataType umlType) {
	match {
		val pcmDeclaration = retrieve pcm::InnerDeclaration corresponding to umlProperty
		val pcmType = retrieve pcm::DataType corresponding to umlType
	}
	action {
		update pcmDeclaration {
			pcmDeclaration.datatype_InnerDeclaration = pcmType
		}
	}
}

// ###################################################
// ############### INTERFACE REACTIONS ###############

reaction CreatedInterface {
	after element uml::Interface created and inserted in uml::Model[packagedElement]
	call createInterface(newValue)
}

routine createInterface(uml::Interface umlInterface) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to umlInterface.model
	}
	action {
		val pcmInterface = create pcm::OperationInterface and initialize {
			pcmInterface.entityName = umlInterface.name
		}
		update pcmRepository {
			pcmRepository.interfaces__Repository += pcmInterface
		}
		add correspondence between umlInterface and pcmInterface
	}
}

reaction CreatedInterfaceOperation {
	after element uml::Operation created and inserted in uml::Interface[ownedOperation]
	call {
		createInterfaceOperation(newValue)
		System.out.println("created interface operation")
		}
}

routine createInterfaceOperation(uml::Operation umlOperation) {
	match {
		val pcmInterface = retrieve pcm::OperationInterface corresponding to umlOperation.interface
	}
	action {
		val pcmOperation = create pcm::OperationSignature and initialize {
			pcmOperation.entityName = umlOperation.name
		}
		update pcmInterface {
			pcmInterface.signatures__OperationInterface += pcmOperation
		}
		add correspondence between umlOperation and pcmOperation
	}
}

reaction ChangedInterfaceOperationTypeI {
	after element inserted in uml::Operation[ownedParameter]
	call addOperationParameter(affectedEObject, newValue)
}

reaction ChangedInterfaceOperationType {
	after element replaced at uml::Parameter[type] with
		(affectedEObject.direction == ParameterDirectionKind.RETURN_LITERAL) &&
		(affectedEObject.owner instanceof Operation)
	call changeInterfaceOperationType((affectedEObject.owner as Operation), affectedEObject)
}

routine addOperationParameter(uml::Operation umlOperation, uml::Parameter umlParameter) {
	match {
		val pcmSignature = retrieve pcm::Signature corresponding to umlOperation
	}
	action {
		call {
			if (umlParameter.direction == ParameterDirectionKind.RETURN_LITERAL) {
				changeInterfaceOperationType(umlOperation, umlParameter)
			}
			else {
				addInterfaceOperationParameter(umlOperation, umlParameter)
			}
		}
	}
}

routine addInterfaceOperationParameter(uml::Operation umlOperation, uml::Parameter umlParameter) {	
	match {
		val pcmSignature = retrieve pcm::OperationSignature corresponding to umlOperation
		val pcmType = retrieve pcm::DataType corresponding to umlParameter.type
	}
	action {
		val pcmParameter = create pcm::Parameter and initialize {
			pcmParameter.parameterName = umlParameter.name
			pcmParameter.entityName = umlParameter.name
		}
		add correspondence between umlParameter and pcmParameter
	}
}

routine changeInterfaceOperationType(uml::Operation umlOperation, uml::Parameter umlParameter) {
	match {
		val pcmSignature = retrieve pcm::OperationSignature corresponding to umlOperation
		val pcmType = retrieve pcm::DataType corresponding to umlParameter.type
	}
	action {
		call println("changing Interface Operation Type")
		update pcmSignature {
			pcmSignature.returnType__OperationSignature = pcmType
		}
	}
}

reaction ChangedParameterType {
	after element replaced at uml::Parameter[type] with affectedEObject.direction != ParameterDirectionKind.RETURN_LITERAL
	call changeParameterType(affectedEObject)
}
routine changeParameterType(uml::Parameter umlParameter) {
	match {
		val pcmParameter = retrieve pcm::Parameter corresponding to umlParameter
		val pcmType = retrieve pcm::DataType corresponding to umlParameter.type
	}
	action {
		update pcmParameter {
			pcmParameter.dataType__Parameter = pcmType
		}
	}
}
reaction ChangedParameterName {
	after attribute replaced at uml::Parameter[name]
	call changeParameterName(affectedEObject)
}
routine changeParameterName(uml::Parameter umlParameter) {
	match {
		val pcmParameter = retrieve pcm::Parameter corresponding to umlParameter
	}
	action {
		update pcmParameter {
			pcmParameter.parameterName = umlParameter.name
			pcmParameter.entityName = umlParameter.name
		}
	}
}
reaction ChangedParameterDirection {
	after attribute replaced at uml::Parameter[direction] with
		(newValue != ParameterDirectionKind.RETURN_LITERAL)
	call changeParameterDirection(affectedEObject)
}
routine changeParameterDirection(uml::Parameter umlParameter) {
	match {
		val pcmParameter = retrieve pcm::Parameter corresponding to umlParameter
	}
	action {
		update pcmParameter {
			pcmParameter.modifier__Parameter = UmlToPcmUtil.getPcmParameterModifier(umlParameter.direction)
		}
	}
}

// ###################################################
// ############### COMPONENT REACTIONS ###############
reaction CreatedComponent {
	after element uml::Component inserted in uml::Model[packagedElement]
	call createPcmComponent(newValue)
}

routine createPcmComponent(uml::Component umlComponent) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to umlComponent.model
	}
	action {
		val pcmComponent = create pcm::CompositeComponent and initialize {
			pcmComponent.entityName = umlComponent.name
		}
		update pcmRepository {
			pcmRepository.components__Repository += pcmComponent
		}
		add correspondence between umlComponent and pcmComponent
	}
}

