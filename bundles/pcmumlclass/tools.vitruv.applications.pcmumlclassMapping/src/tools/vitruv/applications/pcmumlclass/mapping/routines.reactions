import tools.vitruv.applications.pcmumlclass.mapping.TagLiterals
import org.eclipse.uml2.uml.UMLFactory
import tools.vitruv.applications.pcmumlclass.mapping.DefaultLiterals
import static extension tools.vitruv.applications.pcmumlclass.mapping.MappingUpdateHelper.*
import edu.kit.ipd.sdq.commons.util.java.lang.StringUtil
import org.apache.commons.lang3.StringUtils

//will be ignored anyway because we only import the routines
reactions: umlXpcmRoutines 
in reaction to changes in UML
execute actions in PCM

import routines pcmDataTypePropagationReactions using qualified names

//routines to persist the root models

routine createRepositoryRoot(uml::Package repositoryPkg, pcm::Repository repository){
	action{
		execute {
			persistProjectRelative(repositoryPkg, repository, DefaultLiterals.PCM_MODEL_FILE)		
		}		
	}
}

routine createUmlModelRoot(pcm::Repository repository, uml::Package repositoryPkg){
	action{
		execute{
			val umlRootModel = UMLFactory.eINSTANCE.createModel
			umlRootModel.name = 'umlrootmodel'
			umlRootModel.nestedPackages += repositoryPkg
			persistProjectRelative(repository, umlRootModel, DefaultLiterals.UML_MODEL_FILE)			
		}
	}
}

//repository mapping routines

routine updateRepoName(uml::Package repositoryPkg, uml::Package contractsPkg , uml::Package datatypesPkg) {
	match{
		val repository = retrieve pcm::Repository corresponding to repositoryPkg tagged with TagLiterals.REPOSITORY_TO_REPOSITORY_PACKAGE
	} 	
	action {
		execute {
			repository.entityName = repositoryPkg.name.toFirstUpper					
		}
	}
}

routine updateRepoPackageName(repository::Repository repository) {
	match{
		val repositoryPkg = retrieve asserted uml::Package corresponding to repository tagged with TagLiterals.REPOSITORY_TO_REPOSITORY_PACKAGE
	}	
	action {
		update repositoryPkg {
		if (repositoryPkg.name != repository.entityName.toFirstLower)
			repositoryPkg.name = repository.entityName.toFirstLower					
		}
	}
}

//repository component mapping routines 

routine updateComponentName(uml::Package componentPackage, uml::Package repositoryPackage, uml::Class implementation, uml::Operation constructor){
	match{
		val pcmComponent = retrieve pcm::RepositoryComponent corresponding to componentPackage tagged with TagLiterals.REPOSITORY_COMPONENT__PACKAGE
	} 	
	action {
		//check if the componentPackage, implementation or constructor name was updated
		execute {
			//the repository.entityName is used as the interchangeable value source for the update
			val componentUpdate = objectParameter([pcmComponent.entityName], 
				[pcmComponent.entityName = (it as String)]
			)
			val componentPackageSource = objectParameter([componentPackage.name?.toFirstUpper],
				[componentPackage.name = (it as String).toFirstLower]
			)
			val implementationSource = objectParameter([StringUtils.removeEnd(implementation.name,DefaultLiterals.IMPLEMENTATION_SUFFIX)],
				[implementation.name = (it as String)+DefaultLiterals.IMPLEMENTATION_SUFFIX]
			)
			val constructorSource = objectParameter([StringUtils.removeEnd(constructor.name,DefaultLiterals.IMPLEMENTATION_SUFFIX)],
				[constructor.name = (it as String)+DefaultLiterals.IMPLEMENTATION_SUFFIX]
			)
			updateFromSources(componentUpdate, componentPackageSource, implementationSource, constructorSource)			
		}
	}
}
   	 
 routine updateImplementationName(pcm::RepositoryComponent component, pcm::Repository repository){
	match{
		val umlComponentImplementation = retrieve uml::Class corresponding to component tagged with TagLiterals.IPRE__IMPLEMENTATION
	} 	
	action {
		execute {
			umlComponentImplementation.name = component.entityName + DefaultLiterals.IMPLEMENTATION_SUFFIX			
		}
	}
}
   	 
routine updatePackageName(pcm::RepositoryComponent component, pcm::Repository repository){
	match{
		val umlComponentPackage = retrieve uml::Package corresponding to component tagged with TagLiterals.REPOSITORY_COMPONENT__PACKAGE
	} 	
	action {
		execute {
			umlComponentPackage.name = component.entityName.toFirstLower			
		}
	}
 }
   	 
routine updateConstructorName(pcm::RepositoryComponent component, pcm::Repository repository){
	match{
		val umlComponentConstructor = retrieve uml::Operation corresponding to component tagged with TagLiterals.IPRE__CONSTRUCTOR
	} 	
	action {
		execute {
			umlComponentConstructor.name = component.entityName +  DefaultLiterals.IMPLEMENTATION_SUFFIX			
		}
	}
}
   	 
//datatypes mapping routines
 
routine updateClassName(pcm::CompositeDataType type, pcm::Repository repository){
	match{
		val umlCompositeClass = retrieve uml::Class corresponding to type tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
	} 	
	action {
		execute {
			umlCompositeClass.name = type.entityName		
		}
	}
}
   	 	
routine updateCompositeDataTypeName(uml::Class class_, uml::Package datatypesPackage){
	match{
		val pcmCompositeType = retrieve pcm::CompositeDataType corresponding to class_ tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
	} 	
	action {
		execute {
			pcmCompositeType.entityName = class_.name			
		}
	}
}
   	 	
//interface mapping routines
 
routine updateOperationInterfaceName(uml::Interface interface_, uml::Package contractsPackage){
	match{
		val pcmInterface = retrieve pcm::OperationInterface corresponding to interface_ tagged with TagLiterals.INTERFACE_TO_INTERFACE
	} 	
	action {
		execute {
			pcmInterface.entityName = interface_.name		
		}
	}
}
   	 	
routine updateInterfaceName(pcm::OperationInterface operationInterface, pcm::Repository repository){
	match{
		val umlInterface = retrieve uml::Interface corresponding to operationInterface tagged with TagLiterals.INTERFACE_TO_INTERFACE
	} 	
	action {
		execute {
			umlInterface.name = operationInterface.entityName	
		}
	}
}
   	 	
//roles mapping routines
 
routine updateRequiredRoleName(uml::Property property, uml::Parameter parameter, uml::Class implementation, uml::Interface interface_, uml::Operation operation){
	match{
		val role = retrieve pcm::OperationRequiredRole corresponding to property tagged with TagLiterals.REQUIRED_ROLE__PROPERTY
	} 	
	action {
		//check if either the name of the property or parameter was changed
		execute {
			val roleUpdate = simpleEObjectParameter(role, 'entityName')
			val propertySource = simpleEObjectParameter(property, 'name')
			val parameterSource = simpleEObjectParameter(parameter, 'name')
			updateFromSources(roleUpdate, propertySource, parameterSource)
		}
	}
}
   	 	
routine updatePropertyName(pcm::OperationRequiredRole role, pcm::OperationInterface operationInterface, pcm::InterfaceProvidingRequiringEntity requiringEntity){
	match{
		val property = retrieve uml::Property corresponding to role tagged with TagLiterals.REQUIRED_ROLE__PROPERTY
	} 	
	action {
		execute {
			property.name = role.entityName			
		}
	}
}
   	 	
routine updateParameterName(pcm::OperationRequiredRole role, pcm::OperationInterface operationInterface, pcm::InterfaceProvidingRequiringEntity requiringEntity){
	match{
		val parameter = retrieve uml::Parameter corresponding to role tagged with TagLiterals.REQUIRED_ROLE__PARAMETER
	} 	
	action {
		execute {
			parameter.name = role.entityName			
		}
	}
}
   	 	
routine updateProvidedRoleName(uml::InterfaceRealization interfaceRealization, uml::Class implementation, uml::Interface interface_){
	match{
		val role = retrieve pcm::OperationProvidedRole corresponding to interfaceRealization tagged with TagLiterals.PROVIDED_ROLE__INTERFACE_REALIZATION
	} 	
	action {
		execute {
			role.entityName = interfaceRealization.name			
		}
	}
}
   	 	
routine updateInterfaceRealizationName(pcm::OperationProvidedRole role, pcm::OperationInterface operationInterface, pcm::InterfaceProvidingRequiringEntity providingEntity){
	match{
		val interfaceRealization = retrieve uml::InterfaceRealization corresponding to role tagged with TagLiterals.PROVIDED_ROLE__INTERFACE_REALIZATION
	} 	
	action {
		execute {
			interfaceRealization.name = role.entityName 
		}
	}
}  	
   	 	
//signature mapping routines	 	 
 
routine updateOperationName(pcm::OperationSignature operationSignature, pcm::OperationInterface operationInterface){
	match{
		val operation = retrieve uml::Operation corresponding to operationSignature tagged with TagLiterals.SIGNATURE__OPERATION
	} 	
	action {
		execute {
			 operation.name	= operationSignature.entityName
		}
	}
}
   	 	
routine updateOperationSignatureName(uml::Operation operation, uml::Parameter returnParameter, uml::Interface interface_){
	match{
		val operationSignature = retrieve pcm::OperationSignature corresponding to operation tagged with TagLiterals.SIGNATURE__OPERATION
	} 	
	action {
		execute {
			operationSignature.entityName = operation.name			
		}
	}
}
   	 	
 routine updateOperationSignatureReturnType(pcm::OperationSignature operationSignature, pcm::OperationInterface operationInterface){
	match {
		val umlParam = retrieve uml::Parameter corresponding to operationSignature tagged with TagLiterals.SIGNATURE__RETURN_PARAMETER
	}
	action {
		call pcmDataTypePropagationReactions.setUmlParameterType(operationSignature.returnType__OperationSignature, umlParam)
	}
}	  	 	  	 