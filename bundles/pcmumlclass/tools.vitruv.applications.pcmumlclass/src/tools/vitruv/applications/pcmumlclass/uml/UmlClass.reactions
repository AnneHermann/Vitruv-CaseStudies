import org.eclipse.uml2.uml.Class
import org.palladiosimulator.pcm.repository.CompositeDataType
import tools.vitruv.applications.pcmumlclass.TagLiterals
import tools.vitruv.applications.pcmumlclass.DefaultLiterals

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml 
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

reactions: umlClassReactions
in reaction to changes in UML
execute actions in PCM

//TODO System noch nicht behandelt

/*
 * A uml::Class can participate in the following correspondences
 * 		1) pcm::CompositeDatatype 	~ uml::Class 	| the class has to be in the datatypes-pkg
 * 		2) pcm::RepositoryComponent ~ uml::Class	| the class holds the component implementation and is in its own package
 * 		3) pcm::System 				~ uml::Class	| the class holds the system implementation and is contained in its own package
 * 	In cases 2) and 3) the class is generated via round-trip and via convention not removed from the package.
 * 	Because of that we can assume that the insertion or removal of a class participating in these correspondence type do not have to be handled here,
 * 		only attribute changes and deletion.
 */
 
// generalization reactions and routines are handled by:
// 	- UmlCompositeDataTypeGeneralization.reactions
//	- UmlProvidedRoleGeneralization.reactions

reaction ClassInsertedInPkg{
	after element uml::Class inserted in uml::Package[packagedElement]
	with {newValue.package === affectedEObject}
	call matchExistingClassConcepts(newValue, affectedEObject)
}

routine matchExistingClassConcepts(uml::Class umlClass, uml::Package umlPackage){
	match{
		val pcmCompositeType = retrieve optional pcm::CompositeDataType corresponding to umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		val pcmRepositoryComponent = retrieve optional pcm::RepositoryComponent corresponding to umlClass tagged with TagLiterals.IPRE__IMPLEMENTATION
	}
	action{
		call {
			if (pcmRepositoryComponent.isPresent){
				matchComponentClass2InsertionContext(umlClass, umlPackage)
			}
			else if (pcmCompositeType.isPresent){
				matchCompositeTypeClass2InsertionContext(umlClass, umlPackage)
			}
			else{
				contextDisambiguateClassConcepts(umlClass, umlPackage)
			}
		}
	}
}

routine matchComponentClass2InsertionContext(uml::Class umlClass, uml::Package umlPackage){
	match{
		val pcmRepositoryComponent_1 = retrieve optional pcm::RepositoryComponent corresponding to umlClass tagged with TagLiterals.IPRE__IMPLEMENTATION
		val pcmRepositoryComponent_2 = retrieve optional pcm::RepositoryComponent corresponding to umlPackage tagged with TagLiterals.REPOSITORY_COMPONENT__PACKAGE
	}
	action{
		call{
			if (pcmRepositoryComponent_1.isPresent && pcmRepositoryComponent_2.isPresent 
				&& pcmRepositoryComponent_1.get === pcmRepositoryComponent_2.get){
//				Component implementation has been added to the correct package -> do nothing
			}
			else{
				logger.warn("Repository component implementation class has been inserted in the wrong package.")
			}
		}
	}
}

routine matchCompositeTypeClass2InsertionContext(uml::Class umlClass, uml::Package umlPackage){
	match{
		val pcmRepository = retrieve optional pcm::Repository corresponding to umlPackage tagged with TagLiterals.REPOSITORY_TO_DATATYPES_PACKAGE
	}
	action{
		call{
			if (pcmRepository.isPresent){
				moveCompositeTypeClassCorrespondence(umlClass, umlPackage)
			}
			else{
				deleteCompositeTypeClassCorrespondence(umlClass)
//				normal we would now try to search for other possible concepts, but there can't be any
			}
		}
	}
}

routine contextDisambiguateClassConcepts(uml::Class umlClass, uml::Package umlPackage){
	match{
		val pcmRepository = retrieve optional pcm::Repository corresponding to umlPackage tagged with TagLiterals.REPOSITORY_TO_DATATYPES_PACKAGE
	}
	action{
		call{
			if (pcmRepository.isPresent){
				detectCompositeTypeClassCorrespondenceCandidates(umlClass, umlPackage)
			}
			//RepositoryComponentImpl and SystemImpl classes are generated via round-trip and don't need to be handled here
		}
	}
}

routine detectCompositeTypeClassCorrespondenceCandidates(uml::Class umlClass, uml::Package umlPackage){
	match{
		val pcmRepository = retrieve asserted pcm::Repository corresponding to umlPackage tagged with TagLiterals.REPOSITORY_TO_DATATYPES_PACKAGE
	}
	action{
		call{
			val candidates = pcmRepository.dataTypes__Repository.filter(CompositeDataType).filter[type | type.entityName == umlClass.name]
			switch (candidates.size){
				case 0: createCompositeTypeClassCorrespondence(umlClass, umlPackage)
				case 1: addCompositeTypeClassCorrespondence(candidates.head, umlClass)
				default: {
//					userDisambiguateCompositeTypeClassCorrespondenceCandidates(umlClass, umlPackage, candidates) //should not occure -> warning
					logger.warn("Found multiple possible CompositeDatatype correspondence candidates for a class <" + umlClass + "> in the datatypes package")
					addCompositeTypeClassCorrespondence(candidates.head, umlClass)
				}
			}
		}
	}
}

routine createCompositeTypeClassCorrespondence(uml::Class umlClass, uml::Package umlPackage){
	match{
		val pcmRepository = retrieve asserted pcm::Repository corresponding to umlPackage tagged with TagLiterals.REPOSITORY_TO_DATATYPES_PACKAGE
	}
	action{
		val pcmCompositeType = create pcm::CompositeDataType and initialize {
			pcmCompositeType.entityName = umlClass.name
		}
		add correspondence between pcmCompositeType and umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		call moveCompositeTypeClassCorrespondence(umlClass, umlPackage)
	}
}

routine addCompositeTypeClassCorrespondence(pcm::CompositeDataType pcmCompositeType, uml::Class umlClass){
	action{
		add correspondence between pcmCompositeType and umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
	}
}

routine moveCompositeTypeClassCorrespondence(uml::Class umlClass, uml::Package umlPackage){
	match{
		val pcmCompositeType = retrieve asserted pcm::CompositeDataType corresponding to umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		val pcmRepository = retrieve asserted pcm::Repository corresponding to umlPackage tagged with TagLiterals.REPOSITORY_TO_DATATYPES_PACKAGE
	}
	action{
		update pcmCompositeType {
			pcmRepository.dataTypes__Repository += pcmCompositeType
		}
	}
}

reaction ClassRemovedFromPkg {
	after element uml::Class removed from uml::Package[packagedElement]
	with {oldValue.package !== affectedEObject}
	call disambiguateRemovedClassConcept(oldValue, affectedEObject)
}

routine disambiguateRemovedClassConcept(uml::Class umlClass, uml::Package umlPackage){
	match{
		val pcmCompositeType = retrieve optional pcm::CompositeDataType corresponding to umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		val pcmRepositoryComponent = retrieve optional pcm::RepositoryComponent corresponding to umlClass tagged with TagLiterals.IPRE__IMPLEMENTATION
	}
	action{
		call {
			if (pcmRepositoryComponent.isPresent){
				//assume that the change is caused by the removal of pcmRepository type, and that the change is resolved
			}
			else if (pcmCompositeType.isPresent){
				removeCompositeTypeClassCorrespondence(umlClass, umlPackage)
			}
		}
	}
}

routine removeCompositeTypeClassCorrespondence(uml::Class umlClass, uml::Package umlPackage){
	match{
		val pcmCompositeType = retrieve pcm::CompositeDataType corresponding to umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		val pcmRepository = retrieve pcm::Repository corresponding to umlPackage tagged with TagLiterals.REPOSITORY_TO_DATATYPES_PACKAGE
	}
	action{
		update pcmCompositeType {
			pcmRepository.dataTypes__Repository -= pcmCompositeType
		}
	}
}

reaction ClassDeleted {
	after element uml::Class deleted
	call disambiguateDeletedClassConcept(affectedEObject)
}

routine disambiguateDeletedClassConcept(uml::Class umlClass){
	match{
		val pcmCompositeType = retrieve optional pcm::CompositeDataType corresponding to umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		val pcmRepositoryComponent = retrieve optional pcm::RepositoryComponent corresponding to umlClass tagged with TagLiterals.IPRE__IMPLEMENTATION
	}
	action{
		call {
			if (pcmRepositoryComponent.isPresent){
				deleteRepositoryComponentImplCorrespondence(umlClass)
			}
			else if (pcmCompositeType.isPresent){
				deleteCompositeTypeClassCorrespondence(umlClass)
			}
		}
	}
}

routine deleteCompositeTypeClassCorrespondence(uml::Class umlClass){
	match{
		val pcmCompositeType = retrieve pcm::CompositeDataType corresponding to umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
	}
	action{
		remove correspondence between pcmCompositeType and umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		delete pcmCompositeType
	}
}

routine deleteRepositoryComponentImplCorrespondence(uml::Class umlClass){
	match{
		val pcmComponent = retrieve pcm::RepositoryComponent corresponding to umlClass tagged with TagLiterals.IPRE__IMPLEMENTATION
	}
	action{
		remove correspondence between pcmComponent and umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		delete pcmComponent
	}
}


reaction ClassRenamed {
	after attribute replaced at uml::Class[name]
	with {affectedEObject.name == newValue}
	call disambiguateRenamedClassConcept(affectedEObject, newValue)
}

routine disambiguateRenamedClassConcept(uml::Class umlClass, String newName){
	match{
		val pcmCompositeType = retrieve optional pcm::CompositeDataType corresponding to umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		val pcmIPRE = retrieve optional pcm::InterfaceProvidingRequiringEntity corresponding to umlClass tagged with TagLiterals.IPRE__IMPLEMENTATION
		val pcmSystemImpl = retrieve optional pcm::System corresponding to umlClass tagged with TagLiterals.IPRE__IMPLEMENTATION
	}
	action{
		call {
			if (pcmIPRE.isPresent){
				renameIpreImplCorresondenceCorrespondence(umlClass, newName)
			}
			else if (pcmCompositeType.isPresent){
				renameCompositeTypeClassCorrespondence(umlClass, newName)
			}
		}
	}
}

routine renameCompositeTypeClassCorrespondence(uml::Class umlClass, String newName){
	match{
		val pcmCompositeType = retrieve pcm::CompositeDataType corresponding to umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
	}
	action{
		update pcmCompositeType {
			pcmCompositeType.entityName = newName
		}
	}
}

routine renameIpreImplCorresondenceCorrespondence(uml::Class umlClass, String newName){
	match{
		val pcmIPRE = retrieve pcm::InterfaceProvidingRequiringEntity corresponding to umlClass tagged with TagLiterals.IPRE__IMPLEMENTATION
	}
	action{
		update pcmIPRE {
			if (newName.endsWith(DefaultLiterals.IMPLEMENTATION_SUFFIX)){
				pcmIPRE.entityName = newName.substring(0, newName.length - DefaultLiterals.IMPLEMENTATION_SUFFIX.length).toFirstUpper
			}
			else {
				pcmIPRE.entityName = newName
			}
		}
	}
}

