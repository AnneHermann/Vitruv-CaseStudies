import org.eclipse.uml2.uml.LiteralUnlimitedNatural
import tools.vitruv.applications.pcmumlclass.TagLiterals
import org.palladiosimulator.pcm.repository.CollectionDataType
import tools.vitruv.extensions.dslsruntime.reactions.helper.ReactionsCorrespondenceHelper
import tools.vitruv.framework.correspondence.CorrespondenceModelUtil

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml 
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

//	The following routines define how a pcm::DataType change is propagated to the relevant uml::Parameter or uml::Property.
//
//	Since both Parameter and Property inherit from TypedElement and MultiplicityElement, but don't combine those traits, 
//	the routines expect two references to the same element but differently typed.
//
//	Related files: (used in)
//		PcmSignature.reactions,

reactions: pcmDataTypePropagationReactions
in reaction to changes in PCM
execute actions in UML

//routine removeCollectionTypeCorrespondenceFromParameterOrProperty(
//		pcm::CollectionDataType oldCollectionDataType, 
//		uml::TypedElement umlElement, uml::MultiplicityElement umlMultiplicity, // same element; Parameter or Property
//		String tag
//){
//	action {
//		update umlElement {
//			umlElement.type = null
//		}
//		update umlMultiplicity{
//			umlMultiplicity.lower = 1
//			umlMultiplicity.upper = 1
//		}
//		remove correspondence between oldCollectionDataType and umlElement tagged with tag
//	}
//}
//
//routine addCollectionTypeCorrespondenceToParameterOrProperty(
//		pcm::CollectionDataType newCollectionDataType, 
//		uml::TypedElement umlElement, uml::MultiplicityElement umlMultiplicity, // same element; Parameter or Property
//		String tag
//){
//	action {
//		update umlMultiplicity {
//			umlMultiplicity.lower = 0
//			umlMultiplicity.upper = LiteralUnlimitedNatural.UNLIMITED
//		}
//		add correspondence between newCollectionDataType and umlElement tagged with tag
//		call replaceTypeOfCorrespondingParameterOrProperty(newCollectionDataType.innerType_CollectionDataType, umlElement)
//	}
//}
//
//routine replaceTypeOfCorrespondingParameterOrProperty(pcm::DataType pcmSimpleType, uml::TypedElement umlElement){
//	match {
//		val umlPrimitiveType = retrieve optional uml::Type corresponding to pcmSimpleType tagged with TagLiterals.DATATYPE__TYPE
//		val umlCompositeType = retrieve optional uml::Type corresponding to pcmSimpleType tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
//	}
//	action {
//		update umlElement {
//			umlElement.type = umlPrimitiveType.orElse(umlCompositeType.orElse(null))
//		}
//	}
//}

routine setTypeOfUmlParameterOrProperty(
		pcm::DataType pcmType, 
		uml::TypedElement umlElement, uml::MultiplicityElement umlMultiplicity, // same element; Parameter or Property
		String tag
){
	action {
		call {
			if (pcmType !== null && pcmType instanceof CollectionDataType){
				setTypeOfUmlParameterOrProperty_Collection(pcmType as CollectionDataType, umlElement, umlMultiplicity, tag)
			}
			else {
				setTypeOfUmlParameterOrProperty_NonCollection(pcmType, umlElement, umlMultiplicity, tag)
			}
		}
	}
}

routine setTypeOfUmlParameterOrProperty_NonCollection(
		pcm::DataType pcmType, 
		uml::TypedElement umlElement, uml::MultiplicityElement umlMultiplicity, // same element; Parameter or Property
		String tag
){
	match {
		val umlPrimitiveType = retrieve optional uml::Type corresponding to pcmType tagged with TagLiterals.DATATYPE__TYPE
		val umlCompositeType = retrieve optional uml::Type corresponding to pcmType tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
	}
	action {
		update umlElement {
			umlElement.type = umlPrimitiveType.orElse(umlCompositeType.orElse(null))
		}
		update umlMultiplicity {
			umlMultiplicity.lower = 1
			umlMultiplicity.upper = 1
		}
		call removeOldCollectionDataTypeCorrespondence(umlElement, tag)
	}
}

routine setTypeOfUmlParameterOrProperty_Collection(
		pcm::CollectionDataType pcmType, 
		uml::TypedElement umlElement, uml::MultiplicityElement umlMultiplicity, // same element; Parameter or Property
		String tag
){
	match {
		val umlPrimitiveType = retrieve optional uml::Type corresponding to pcmType.innerType_CollectionDataType tagged with TagLiterals.DATATYPE__TYPE
		val umlCompositeType = retrieve optional uml::Type corresponding to pcmType.innerType_CollectionDataType tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
	}
	action {
		update umlElement {
			umlElement.type = umlPrimitiveType.orElse(umlCompositeType.orElse(null))
		}
		update umlMultiplicity {
			umlMultiplicity.lower = 0
			umlMultiplicity.upper = LiteralUnlimitedNatural.UNLIMITED
		}
		call removeOldCollectionDataTypeCorrespondence(umlElement, tag)
		call addCollectionDataTypeCorrespondence(pcmType, umlElement, tag)
	}
}


routine removeOldCollectionDataTypeCorrespondence(
		uml::TypedElement umlElement, // Parameter or Property
		String tag
){
	match {
		val oldCollectionType = retrieve pcm::CollectionDataType corresponding to umlElement tagged with tag
	}
	action {
//		execute{
//			ReactionsCorrespondenceHelper.removeCorrespondencesBetweenElements(correspondenceModel, oldCollectionType, umlElement, tag)
//		}
		remove correspondence between oldCollectionType and umlElement tagged with tag // TODO does not work without tags
	}
}

routine addCollectionDataTypeCorrespondence(
		pcm::CollectionDataType pcmType, 
		uml::TypedElement umlElement, // Parameter or Property
		String tag
){
	match {
		require absence of pcm::CollectionDataType corresponding to umlElement tagged with tag
	}
	action {
		add correspondence between pcmType and umlElement tagged with tag
	}
}





