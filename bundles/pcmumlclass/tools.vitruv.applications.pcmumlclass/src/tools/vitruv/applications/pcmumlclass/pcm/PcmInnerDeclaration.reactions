import tools.vitruv.applications.pcmumlclass.TagLiterals
import org.palladiosimulator.pcm.repository.CollectionDataType
import org.eclipse.uml2.uml.LiteralUnlimitedNatural

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml 
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

//	The following reactions and routines synchronize a pcm::InnerDeclaration with its corresponding uml::Property.
//
//	Related files: 
//		UmlReturnAndRegularParameterType.reactions,
//		AttributeConceptTest

reactions: pcmInnerDeclarationReactions
in reaction to changes in PCM
execute actions in UML

// TODO can't import the same routines in multiple Reaction files. Even using qualified-non qualified names I only get two imports but I need three.   
//import routines pcmDataTypePropagationReactions using qualified names

reaction InnerDeclarationInserted{
	after element pcm::InnerDeclaration inserted in pcm::CompositeDataType[innerDeclaration_CompositeDataType]
	with {affectedEObject.innerDeclaration_CompositeDataType.contains(newValue)}
	call insertCorrespondingAttribute(newValue, affectedEObject)
}

routine insertCorrespondingAttribute(pcm::InnerDeclaration pcmAttribute, pcm::CompositeDataType pcmComposite){
	action {
		call detectOrCreateCorrespondingAttribute(pcmAttribute, pcmComposite)
		call moveCorrespondingAttribute(pcmAttribute, pcmComposite)
	}
}

routine detectOrCreateCorrespondingAttribute(pcm::InnerDeclaration pcmAttribute, pcm::CompositeDataType pcmComposite){
	match{
		val umlComposite = retrieve uml::Class corresponding to pcmComposite tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		val umlAttribute = retrieve optional uml::Property corresponding to pcmAttribute tagged with TagLiterals.INNER_DECLARATION__PROPERTY
	}
	action {
		call {
			if (!umlAttribute.isPresent) {
				val umlAttributeCandidate = umlComposite.ownedAttributes.findFirst[it.name == pcmAttribute.entityName]
				if (umlAttributeCandidate !== null){
					addCorrespondenceForExistingAttribute(pcmAttribute, umlAttributeCandidate)
				}
				else {
					createCorrespondingAttribute(pcmAttribute, pcmComposite)
				}
			}
		}
	}
}

routine addCorrespondenceForExistingAttribute(pcm::InnerDeclaration pcmAttribute, uml::Property umlAttribute){
	match{
		require absence of uml::Property corresponding to pcmAttribute tagged with TagLiterals.INNER_DECLARATION__PROPERTY
		require absence of pcm::InnerDeclaration corresponding to umlAttribute tagged with TagLiterals.INNER_DECLARATION__PROPERTY
	}
	action {
		add correspondence between pcmAttribute and umlAttribute tagged with TagLiterals.INNER_DECLARATION__PROPERTY
	}
}

routine createCorrespondingAttribute(pcm::InnerDeclaration pcmAttribute, pcm::CompositeDataType pcmComposite){
	match{
		val umlComposite = retrieve uml::Class corresponding to pcmComposite tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		require absence of uml::Property corresponding to pcmAttribute tagged with TagLiterals.INNER_DECLARATION__PROPERTY
	}
	action {
		val umlAttribute = create uml::Property and initialize {
			umlAttribute.name = pcmAttribute.entityName
		}
		add correspondence between pcmAttribute and umlAttribute tagged with TagLiterals.INNER_DECLARATION__PROPERTY
		call changeTypeOfCorrespondingAttribute(pcmAttribute, pcmAttribute.datatype_InnerDeclaration)
	}
}

routine moveCorrespondingAttribute(pcm::InnerDeclaration pcmAttribute, pcm::CompositeDataType pcmComposite){
	match{
		val umlComposite = retrieve uml::Class corresponding to pcmComposite tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		val umlAttribute = retrieve uml::Property corresponding to pcmAttribute tagged with TagLiterals.INNER_DECLARATION__PROPERTY
	}
	action {
		update umlComposite {
			umlComposite.ownedAttributes += umlAttribute
		}
	}
}

reaction InnerDeclarationRemoved {
	after element pcm::InnerDeclaration removed from pcm::CompositeDataType[innerDeclaration_CompositeDataType]
	with {!affectedEObject.innerDeclaration_CompositeDataType.contains(oldValue)}
	call removeCorrespondingAttribute(oldValue, affectedEObject)
}

routine removeCorrespondingAttribute(pcm::InnerDeclaration pcmAttribute, pcm::CompositeDataType pcmComposite){
	match{
		val umlComposite = retrieve uml::Class corresponding to pcmComposite tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		val umlAttribute = retrieve uml::Property corresponding to pcmAttribute tagged with TagLiterals.INNER_DECLARATION__PROPERTY
	}
	action {
		update umlComposite {
			umlComposite.ownedAttributes -= umlAttribute
		}
	}
}

reaction InnerDeclarationDeleted {
	after element pcm::InnerDeclaration deleted
	call deleteCorrespondingAttribute(affectedEObject)
}

routine deleteCorrespondingAttribute(pcm::InnerDeclaration pcmAttribute){
	match{
		val umlAttribute = retrieve uml::Property corresponding to pcmAttribute tagged with TagLiterals.INNER_DECLARATION__PROPERTY
	}
	action {
		remove correspondence between pcmAttribute and umlAttribute tagged with TagLiterals.INNER_DECLARATION__PROPERTY
		delete umlAttribute
	}
}

reaction InnerDeclarationNameChanged {
	after attribute replaced at pcm::InnerDeclaration[entityName]
	with {affectedEObject.entityName == newValue}
	call changeNameOfCorrespondingAttribute(affectedEObject, newValue)
}

routine changeNameOfCorrespondingAttribute(pcm::InnerDeclaration pcmAttribute, String newName){
	match{
		val umlAttribute = retrieve uml::Property corresponding to pcmAttribute tagged with TagLiterals.INNER_DECLARATION__PROPERTY
	}
	action {
		update umlAttribute {
			umlAttribute.name = newName
		}
	}
}

// Following reactions are very similar to to PcmSignature.reactions and PcmParameter.reactions.
// See PcmCollectionDataType.reactions for more explanation.
reaction InnerDeclarationTypeChanged {
	after element pcm::DataType replaced at pcm::InnerDeclaration[datatype_InnerDeclaration]
	with {affectedEObject.datatype_InnerDeclaration === newValue && newValue != oldValue}
	call changeTypeOfCorrespondingAttribute(affectedEObject, newValue)
}

//routine changeTypeOfCorrespondingAttribute(pcm::InnerDeclaration pcmInnerDeclaration, pcm::DataType pcmDataType){
//	match {
//		val umlProperty = retrieve uml::Property corresponding to pcmInnerDeclaration tagged with TagLiterals.INNER_DECLARATION__PROPERTY
//		val previousTypeWasCollectionType = retrieve optional pcm::CollectionDataType corresponding to umlProperty tagged with TagLiterals.COLLECTION_DATATYPE__PROPERTY
//	}
//	action {
//		execute {			
//			if (previousTypeWasCollectionType.isPresent){
//				pcmDataTypePropagationReactions.removeCollectionTypeCorrespondenceFromParameterOrProperty(previousTypeWasCollectionType.get, umlProperty, umlProperty, TagLiterals.COLLECTION_DATATYPE__PROPERTY)
//			}
//			if (pcmDataType instanceof CollectionDataType){
//				pcmDataTypePropagationReactions.addCollectionTypeCorrespondenceToParameterOrProperty(pcmDataType, umlProperty, umlProperty, TagLiterals.COLLECTION_DATATYPE__PROPERTY)
//			}
//			else {
//				pcmDataTypePropagationReactions.replaceTypeOfCorrespondingParameterOrProperty(pcmDataType, umlProperty)
//			}
//		}
//	}
//}

routine changeTypeOfCorrespondingAttribute(pcm::InnerDeclaration pcmInnerDeclaration, pcm::DataType pcmDataType){
	match {
		val umlProperty = retrieve uml::Property corresponding to pcmInnerDeclaration tagged with TagLiterals.INNER_DECLARATION__PROPERTY
		val previousTypeWasCollectionType = retrieve optional pcm::CollectionDataType corresponding to umlProperty tagged with TagLiterals.COLLECTION_DATATYPE__PROPERTY
	}
	action {
		execute {			
			if (previousTypeWasCollectionType.isPresent){
				removeCollectionTypeCorrespondenceFromAttribute(pcmInnerDeclaration)
			}
			if (pcmDataType instanceof CollectionDataType){
				addCollectionTypeCorrespondenceToAttribute(pcmInnerDeclaration, pcmDataType)
			}
			else {
				replaceTypeOfCorrespondingAttribute(pcmInnerDeclaration, pcmDataType)
			}
		}
	}
}

routine removeCollectionTypeCorrespondenceFromAttribute(pcm::InnerDeclaration pcmInnerDeclaration){
	match {
		val umlProperty = retrieve uml::Property corresponding to pcmInnerDeclaration tagged with TagLiterals.INNER_DECLARATION__PROPERTY
		val pcmPreviousCollectionType = retrieve asserted pcm::CollectionDataType corresponding to umlProperty tagged with TagLiterals.COLLECTION_DATATYPE__PROPERTY
	}
	action {
		update umlProperty {
			umlProperty.type = null
			umlProperty.lower = 1
			umlProperty.upper = 1
		}
		remove correspondence between pcmPreviousCollectionType and umlProperty tagged with TagLiterals.COLLECTION_DATATYPE__PROPERTY
	}
}

routine addCollectionTypeCorrespondenceToAttribute(pcm::InnerDeclaration pcmAttribute, pcm::CollectionDataType pcmCollectionType){
	match {
		val umlAttribute = retrieve uml::Property corresponding to pcmAttribute tagged with TagLiterals.INNER_DECLARATION__PROPERTY
	}
	action {
		update umlAttribute {
			umlAttribute.lower = 0
			umlAttribute.upper = LiteralUnlimitedNatural.UNLIMITED
		}
		add correspondence between pcmCollectionType and umlAttribute tagged with TagLiterals.COLLECTION_DATATYPE__PROPERTY
		call replaceTypeOfCorrespondingAttribute(pcmAttribute, pcmCollectionType.innerType_CollectionDataType)
	}
}

routine replaceTypeOfCorrespondingAttribute(pcm::InnerDeclaration pcmAttribute, pcm::DataType pcmSimpleType){
	match {
		val umlAttribute = retrieve uml::Property corresponding to pcmAttribute tagged with TagLiterals.INNER_DECLARATION__PROPERTY
		val umlPrimitiveType = retrieve optional uml::Type corresponding to pcmSimpleType tagged with TagLiterals.DATATYPE__TYPE
		val umlCompositeType = retrieve optional uml::Type corresponding to pcmSimpleType tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
	}
	action {
		update umlAttribute {
			umlAttribute.type = umlPrimitiveType.orElse(umlCompositeType.orElse(null))
		}
	}
}




