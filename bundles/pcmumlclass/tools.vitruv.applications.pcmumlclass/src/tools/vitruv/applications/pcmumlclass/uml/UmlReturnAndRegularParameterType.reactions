import org.eclipse.uml2.uml.LiteralUnlimitedNatural
import org.palladiosimulator.pcm.repository.CollectionDataType
import tools.vitruv.applications.pcmumlclass.TagLiterals

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml 
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

//	The following reactions and routines handle type and multiplicity changes for an uml::Parameter corresponding to 
//	a pcm::Signature (return parameter) or a pcm::Parameter in an pcm::Signature (regular Parameter)
//
// 	For more details see PcmCollectionDataType.reactions.
//
//	Related files: 
//		PcmCollectionDataType.reactions
//		PcmSignature.reactions, PcmParameter.reactions
//		UmlRegularParameter.reactions
//		SignatureConceptTest, ParameterConceptTest

reactions: umlReturnAndRegularParameterTypeReactions
in reaction to changes in UML
execute actions in PCM

reaction RegularOrReturnParameterTypeChanged {
	after element replaced at uml::Parameter[type]
	with {affectedEObject.type === newValue && oldValue !== newValue}
	call changeTypeOfCorrespondingParameterOrSignature(affectedEObject, newValue)
}

// On a Type change, establish a correspondence to a new matching CollectionDataType rather then changing the inner type of the old CollectionDataType
routine changeTypeOfCorrespondingParameterOrSignature(uml::Parameter umlParameter, uml::Type newType){
	match {
		val pcmSignature = retrieve optional pcm::OperationSignature corresponding to umlParameter tagged with TagLiterals.SIGNATURE__RETURN_PARAMETER
		val pcmParameter = retrieve optional pcm::Parameter corresponding to umlParameter tagged with TagLiterals.PARAMETER__REGULAR_PARAMETER
	}
	action {
		call {
			if(pcmSignature.isPresent || pcmParameter.isPresent){ // limit context to synchronized uml::Parameters
				if(umlParameter.lower == 0 && umlParameter.upper == LiteralUnlimitedNatural.UNLIMITED){
					removeCorrespondenceForOldCollectionType_Parameter(umlParameter)
					detectOrCreateDefaultCollectionType_Parameter(umlParameter, newType)
				}
				changeTypeOfUmlParameterCorrespondence(umlParameter)
			}
		}
	}
}

routine removeCorrespondenceForOldCollectionType_Parameter(uml::Parameter umlParameter){
	match {
		val pcmCollectionType = retrieve pcm::CollectionDataType corresponding to umlParameter tagged with TagLiterals.COLLECTION_DATATYPE__PARAMETER
	}
	action {
		remove correspondence between pcmCollectionType and umlParameter tagged with TagLiterals.COLLECTION_DATATYPE__PARAMETER
	}
}
routine addCorrespondenceForCollectionType_Parameter(uml::Parameter umlParameter, pcm::CollectionDataType pcmCollectionType){
	match {
		// one Parameter can only correspond to one CollectionDataType, but one CollectionDataType can correspond to many Parameters
		require absence of pcm::CollectionDataType corresponding to umlParameter tagged with TagLiterals.COLLECTION_DATATYPE__PARAMETER
	}
	action {
		add correspondence between pcmCollectionType and umlParameter tagged with TagLiterals.COLLECTION_DATATYPE__PARAMETER
	}
}

routine detectOrCreateDefaultCollectionType_Parameter(uml::Parameter umlParameter, uml::Type newType){
	match {
		val pcmPrimitiveType = retrieve optional pcm::DataType corresponding to newType tagged with TagLiterals.DATATYPE__TYPE 
		val pcmCompositeType = retrieve optional pcm::DataType corresponding to newType tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS 
	}
	action {
		call {
			val pcmDataType = pcmPrimitiveType.orElse(pcmCompositeType.orElse(null))
			if (pcmDataType === null){
				// assume this is a transitional state and do nothing until a type is set
				return
			}
			val pcmRepository = pcmDataType.repository__DataType
			val pcmCollectionTypeCandidate = pcmRepository.dataTypes__Repository.filter(CollectionDataType).findFirst[it.innerType_CollectionDataType == pcmDataType]
			if(pcmCollectionTypeCandidate !== null){
				addCorrespondenceForCollectionType_Parameter(umlParameter, pcmCollectionTypeCandidate)
			}
			else {
				createCorrespondingDefaultCollectionDataType_Parameter(umlParameter, pcmDataType, pcmRepository)
			}
		}
	}
}


routine createCorrespondingDefaultCollectionDataType_Parameter(uml::Parameter umlParameter, pcm::DataType pcmInnerType, pcm::Repository pcmRepository){
	match{
		require absence of pcm::CollectionDataType corresponding to umlParameter tagged with TagLiterals.COLLECTION_DATATYPE__PARAMETER
	}
	action{
		val pcmCollectionType = create pcm::CollectionDataType and initialize {
			pcmCollectionType.entityName = umlParameter.type.name + "_CollectionDataType"
			pcmCollectionType.innerType_CollectionDataType = pcmInnerType
			
			pcmRepository.dataTypes__Repository += pcmCollectionType
		} 
		add correspondence between pcmCollectionType and umlParameter tagged with TagLiterals.COLLECTION_DATATYPE__PARAMETER
	}
}

routine changeTypeOfUmlParameterCorrespondence(uml::Parameter umlParameter){
	match {
		val pcmSignature = retrieve optional pcm::OperationSignature corresponding to umlParameter tagged with TagLiterals.SIGNATURE__RETURN_PARAMETER
		val pcmParameter = retrieve optional pcm::Parameter corresponding to umlParameter tagged with TagLiterals.PARAMETER__REGULAR_PARAMETER
		
		val pcmCollectionType = retrieve optional pcm::DataType corresponding to umlParameter tagged with TagLiterals.COLLECTION_DATATYPE__PARAMETER
		val pcmPrimitiveType = retrieve optional pcm::DataType corresponding to umlParameter.type tagged with TagLiterals.DATATYPE__TYPE 
		val pcmCompositeType = retrieve optional pcm::DataType corresponding to umlParameter.type tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS 
	}
	action {
		execute {
			//important to check for the collection type first, since its presence does not eliminate the presence of the other type correspondences
			val pcmDataType = pcmCollectionType.orElse(pcmPrimitiveType.orElse(pcmCompositeType.orElse(null)))
			if(pcmSignature.isPresent){
				pcmSignature.get.returnType__OperationSignature = pcmDataType
			}
			else if(pcmParameter.isPresent){
				pcmParameter.get.dataType__Parameter = pcmDataType
			}
		}
	}
}

reaction RegularOrReturnParameterLowerChanged{
	after element replaced at uml::Parameter[lowerValue]
	call regularOrReturnParameterMultiplicityChanged(affectedEObject)
}

reaction RegularOrReturnParameterUpperChanged{
	after element replaced at uml::Parameter[upperValue]
	call regularOrReturnParameterMultiplicityChanged(affectedEObject)
}

routine regularOrReturnParameterMultiplicityChanged(uml::Parameter umlParameter){
	match {
		val pcmSignature = retrieve optional pcm::OperationSignature corresponding to umlParameter tagged with TagLiterals.SIGNATURE__RETURN_PARAMETER
		val pcmParameter = retrieve optional pcm::Parameter corresponding to umlParameter tagged with TagLiterals.PARAMETER__REGULAR_PARAMETER
		
		val pcmCollectionType = retrieve optional pcm::CollectionDataType corresponding to umlParameter tagged with TagLiterals.COLLECTION_DATATYPE__PROPERTY
	}
	action {
		call {
			if (pcmSignature.isPresent || pcmParameter.isPresent){ // limit context to synchronized uml::Parameters
				if (umlParameter.lower == 0 && umlParameter.upper == LiteralUnlimitedNatural.UNLIMITED){
					detectOrCreateDefaultCollectionType_Parameter(umlParameter, umlParameter.type)
				} 
				else {
					// should not correspond to a collection type because of mismatching multiplicity
					if(pcmCollectionType.isPresent)
						removeCorrespondenceForOldCollectionType_Parameter(umlParameter)
				}
				changeTypeOfUmlParameterCorrespondence(umlParameter)
			}
		}
	}
}

