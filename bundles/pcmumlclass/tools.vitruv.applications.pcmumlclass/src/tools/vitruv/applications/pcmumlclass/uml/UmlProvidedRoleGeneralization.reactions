import org.palladiosimulator.pcm.repository.OperationProvidedRole
import tools.vitruv.applications.pcmumlclass.TagLiterals

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml 
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

//	The following reactions and routines synchronize a pcm::OperationProvidedRole in an pcm::InterfaceProvidingRequiringEntity (IPRE)
//	with an uml::Generalization in the uml::Class (implementation) corresponding to the IPRE.
//
//	Because a pcm::OperationProvidedRole defines which Interface are provided/implemented by the IPRE, 
//	only architecturally relevant uml::Interfaces (uml::Interfaces that are defined in the contracts package of a pcm::Repository)
//	should be set for uml::Generalization[general] of the IPRE implementation class.
//
//	Related files: 
//		PcmProvidedRole.reactions, 
//		UmlProvidedRoleGeneralization.reactions,
//		ProvidedRoleTest

reactions: umlProvidedRoleGeneralizationReactions
in reaction to changes in UML
execute actions in PCM

reaction ProvidedRoleGeneralizationAdded {
	after element uml::Generalization inserted in uml::Class[generalization]
	with {affectedEObject.generalizations.contains(newValue)} //validity check
	call insertCorrespondingProvidedRole(newValue, affectedEObject)
}

routine insertCorrespondingProvidedRole(uml::Generalization umlGeneralization, uml::Class umlComponent){
	match{
		// context check
		val pcmComponent = retrieve optional pcm::InterfaceProvidingRequiringEntity corresponding to umlComponent tagged with TagLiterals.IPRE__IMPLEMENTATION
		val pcmInterface = retrieve optional pcm::OperationInterface corresponding to umlGeneralization.general tagged with TagLiterals.INTERFACE_TO_INTERFACE
	}
	action {
		call {
			if (pcmComponent.isPresent 
				&& (pcmInterface.isPresent || umlGeneralization.general === null) // allow 'null' for uninitialized Generalizations
			){
				debugging_detectOrCreateCorrespondingProvidedRole(umlGeneralization, umlComponent)
				moveCorrespondingProvidedRole(umlGeneralization, umlComponent)
			}
			else {
				// not a matching context -> delete correspondence, if it exists
				deleteCorrespondingProvidedRole(umlGeneralization)
			}
		}
	}
}

//TODO remove debugging code
routine debugging_detectOrCreateCorrespondingProvidedRole(uml::Generalization umlGeneralization, uml::Class umlComponent){
	match{
		val pcmComponent = retrieve pcm::InterfaceProvidingRequiringEntity corresponding to umlComponent tagged with TagLiterals.IPRE__IMPLEMENTATION
		val pcmInterface = retrieve pcm::OperationInterface corresponding to umlGeneralization.general tagged with TagLiterals.INTERFACE_TO_INTERFACE
		val pcmProvided = retrieve many pcm::OperationProvidedRole corresponding to umlGeneralization tagged with TagLiterals.PROVIDED_ROLE__GENERALIZATION
	}
	action {
		call {
			if (pcmProvided.size > 1){
				logger.warn("Multiple corresponding pcm::OperationProvidedRoles for one uml::Generalization:"
					+ pcmProvided.map[it.entityName]
				)
			}
			else{
				detectOrCreateCorrespondingProvidedRole(umlGeneralization, umlComponent)	
			}	
		}
	}
}

routine detectOrCreateCorrespondingProvidedRole(uml::Generalization umlGeneralization, uml::Class umlComponent){
	match{
		val pcmComponent = retrieve pcm::InterfaceProvidingRequiringEntity corresponding to umlComponent tagged with TagLiterals.IPRE__IMPLEMENTATION
		val pcmInterface = retrieve pcm::OperationInterface corresponding to umlGeneralization.general tagged with TagLiterals.INTERFACE_TO_INTERFACE
		val pcmProvided = retrieve optional pcm::OperationProvidedRole corresponding to umlGeneralization tagged with TagLiterals.PROVIDED_ROLE__GENERALIZATION
	}
	action {
		call {
			if (!pcmProvided.isPresent){
				val pcmProvidedCandidate = pcmComponent.providedRoles_InterfaceProvidingEntity
					.filter(OperationProvidedRole).findFirst[it.providedInterface__OperationProvidedRole === pcmInterface]
				if (pcmProvidedCandidate !== null){
					addCorrespondenceForExistingProvidedRole(umlGeneralization, pcmProvidedCandidate)
				}
				else {
					createCorrespondingProvidedRole(umlGeneralization, umlComponent)
				}
			}
		}
	}
}

routine addCorrespondenceForExistingProvidedRole(uml::Generalization umlGeneralization, pcm::OperationProvidedRole pcmProvided){
	match{
		require absence of uml::Generalization corresponding to pcmProvided tagged with TagLiterals.PROVIDED_ROLE__GENERALIZATION
		require absence of pcm::OperationProvidedRole corresponding to umlGeneralization tagged with TagLiterals.PROVIDED_ROLE__GENERALIZATION
	}
	action {
		add correspondence between pcmProvided and umlGeneralization tagged with TagLiterals.PROVIDED_ROLE__GENERALIZATION
	}
}

routine createCorrespondingProvidedRole(uml::Generalization umlGeneralization, uml::Class umlComponent){
	match{
		val pcmComponent = retrieve pcm::InterfaceProvidingRequiringEntity corresponding to umlComponent tagged with TagLiterals.IPRE__IMPLEMENTATION
		val pcmInterface = retrieve pcm::OperationInterface corresponding to umlGeneralization.general tagged with TagLiterals.INTERFACE_TO_INTERFACE
		require absence of pcm::OperationProvidedRole corresponding to umlGeneralization tagged with TagLiterals.PROVIDED_ROLE__GENERALIZATION
	}
	action {
		val pcmProvided = create pcm::OperationProvidedRole and initialize {
			pcmProvided.providedInterface__OperationProvidedRole = pcmInterface
			pcmComponent.providedRoles_InterfaceProvidingEntity += pcmProvided
		}
		add correspondence between pcmProvided and umlGeneralization tagged with TagLiterals.PROVIDED_ROLE__GENERALIZATION
	}
}

routine moveCorrespondingProvidedRole(uml::Generalization umlGeneralization, uml::Class umlComponent){
	match{
		val pcmComponent = retrieve pcm::InterfaceProvidingRequiringEntity corresponding to umlComponent tagged with TagLiterals.IPRE__IMPLEMENTATION
		val pcmProvided = retrieve pcm::OperationProvidedRole corresponding to umlGeneralization tagged with TagLiterals.PROVIDED_ROLE__GENERALIZATION
	}
	action {
		update pcmComponent {
			pcmComponent.providedRoles_InterfaceProvidingEntity += pcmProvided
		}
	}
}

reaction ProvidedRoleGeneralizationRemoved {
	after element uml::Generalization removed from uml::Class[generalization]
	with {!affectedEObject.generalizations.contains(oldValue)} //validity check
	call removeCorrespondingProvidedRole(oldValue, affectedEObject)
}

routine removeCorrespondingProvidedRole(uml::Generalization umlGeneralization, uml::Class umlComponent){
	match{
		val pcmComponent = retrieve pcm::InterfaceProvidingRequiringEntity corresponding to umlComponent tagged with TagLiterals.IPRE__IMPLEMENTATION
		val pcmProvided = retrieve pcm::OperationProvidedRole corresponding to umlGeneralization tagged with TagLiterals.PROVIDED_ROLE__GENERALIZATION
	}
	action {
		update pcmComponent {
			pcmComponent.providedRoles_InterfaceProvidingEntity -= pcmProvided
		}
	}
}

reaction ProvidedRoleGeneralizationDeleted {
	after element uml::Generalization deleted
	call deleteCorrespondingProvidedRole(affectedEObject)
}

routine deleteCorrespondingProvidedRole(uml::Generalization umlGeneralization){
	match{
		val pcmProvided = retrieve pcm::OperationProvidedRole corresponding to umlGeneralization tagged with TagLiterals.PROVIDED_ROLE__GENERALIZATION
	}
	action {
		remove correspondence between pcmProvided and umlGeneralization tagged with TagLiterals.PROVIDED_ROLE__GENERALIZATION
		delete pcmProvided
	}
}

reaction ProvidedRoleGeneralizationTypeChanged {
	after element uml::Interface replaced at uml::Generalization[general]
	with {affectedEObject.general === newValue}
	call changeTypeOfCorrespondingProvidedRole(affectedEObject, newValue)
}

routine changeTypeOfCorrespondingProvidedRole(uml::Generalization umlGeneralization, uml::Interface umlNewInterface){
	match{
		val pcmComponent = retrieve pcm::InterfaceProvidingRequiringEntity corresponding to umlGeneralization.specific tagged with TagLiterals.IPRE__IMPLEMENTATION
		val pcmProvided = retrieve optional pcm::OperationProvidedRole corresponding to umlGeneralization tagged with TagLiterals.PROVIDED_ROLE__GENERALIZATION
		val pcmNewInterface = retrieve optional pcm::OperationInterface corresponding to umlNewInterface tagged with TagLiterals.INTERFACE_TO_INTERFACE
	}
	action {
		execute {
			if (!pcmProvided.isPresent && pcmNewInterface.isPresent){
				createCorrespondingProvidedRole(umlGeneralization, umlGeneralization.specific as org.eclipse.uml2.uml.Class)
			}
			else if (pcmProvided.isPresent && pcmNewInterface.isPresent){
				pcmProvided.get.providedInterface__OperationProvidedRole = pcmNewInterface.get
			}
			else if(pcmProvided.isPresent && umlNewInterface === null){
				//might be a transitional state -> keep correspondence, but synchronize 'null'
				pcmProvided.get.providedInterface__OperationProvidedRole = null
			}
			else {
				logger.warn("The general-type of a uml::Generalization in a pcm::OperationProvidedRole ~ uml::Generalization correspondence"
							+ "has been set to a non-OperationInterface type. This is against convention and the corresponding OperationProvidedRole will be deleted.")
				deleteCorrespondingProvidedRole(umlGeneralization)
			}
		}
	}
}









