import edu.kit.ipd.sdq.commons.util.org.eclipse.emf.common.util.URIUtil
import tools.vitruv.applications.pcmumlclass.DefaultLiterals
import tools.vitruv.applications.pcmumlclass.PcmUmlClassHelper
import tools.vitruv.applications.pcmumlclass.TagLiterals
import tools.vitruv.extensions.dslsruntime.reactions.helper.PersistenceHelper
import tools.vitruv.framework.userinteraction.UserInteractionType
import org.palladiosimulator.pcm.repository.CompositeDataType

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml 
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

reactions: umlClassReactions
in reaction to changes in UML
execute actions in PCM

//TODO System noch nicht behandelt

/*
 * A uml::Class can participate in the following correspondences
 * 		1) pcm::CompositeDatatype 	~ uml::Class 	| the class has to be in the datatypes-pkg
 * 		2) pcm::RepositoryComponent ~ uml::Class	| the class holds the component implementation and is in its own package
 * 		3) pcm::System 				~ uml::Class	| the class holds the system implementation and is contained in its own package
 * 	In cases 2) and 3) the class is generated via round-trip and via convention not removed from the package.
 * 	Because of that we can assume that the insertion or removal of a class participating in these correspondence type do not have to be handled here,
 * 		only attribute changes and deletion.
 */

reaction ClassInsertedInPkg{
	after element uml::Class inserted in uml::Package[packagedElement]
	with {newValue.package === affectedEObject}
	call matchExistingClassConcepts(newValue, affectedEObject)
}

routine matchExistingClassConcepts(uml::Class umlClass, uml::Package umlPackage){
	match{
		val pcmCompositeType = retrieve optional pcm::CompositeDataType corresponding to umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		val pcmRepositoryComponent = retrieve optional pcm::RepositoryComponent corresponding to umlClass tagged with TagLiterals.REPOSITORY_COMPONENT_TO_CLASS
	}
	action{
		call {
			if (pcmRepositoryComponent.isPresent){
				matchComponentClass2InsertionContext(umlClass, umlPackage)
			}
			else if (pcmCompositeType.isPresent){
				matchCompositeTypeClass2InsertionContext(umlClass, umlPackage)
			}
			else{
				contextDisambiguateClassConcepts(umlClass, umlPackage)
			}
		}
	}
}

routine matchComponentClass2InsertionContext(uml::Class umlClass, uml::Package umlPackage){
	match{
		val pcmRepositoryComponent_1 = retrieve optional pcm::RepositoryComponent corresponding to umlClass tagged with TagLiterals.REPOSITORY_COMPONENT_TO_CLASS
		val pcmRepositoryComponent_2 = retrieve optional pcm::RepositoryComponent corresponding to umlPackage tagged with TagLiterals.REPOSITORY_COMPONENT_TO_PACKAGE
	}
	action{
		call{
			if (pcmRepositoryComponent_1.isPresent && pcmRepositoryComponent_2.isPresent 
				&& pcmRepositoryComponent_1.get === pcmRepositoryComponent_2.get
			){
//				Component implementation has been added to the correct package -> do nothing
			}
			else{
				logger.warn("Repository component implementation class has been inserted in the wrong package.")
			}
		}
	}
}

routine matchCompositeTypeClass2InsertionContext(uml::Class umlClass, uml::Package umlPackage){
	match{
		val pcmRepository = retrieve optional pcm::Repository corresponding to umlPackage tagged with TagLiterals.REPOSITORY_TO_DATATYPES_PACKAGE
	}
	action{
		call{
			if (pcmRepository.isPresent){
				moveCompositeTypeClassCorrespondence(umlClass, umlPackage)
			}
			else{
				deleteCompositeTypeClassCorrespondence(umlClass)
//				normal we would now try to search for other possible concepts, but there can't be
			}
		}
	}
}

routine contextDisambiguateClassConcepts(uml::Class umlClass, uml::Package umlPackage){
	match{
		val pcmRepository = retrieve optional pcm::Repository corresponding to umlPackage tagged with TagLiterals.REPOSITORY_TO_DATATYPES_PACKAGE
	}
	action{
		call{
			if (pcmRepository.isPresent){
				detectCompositeTypeClassCorrespondenceCandidates(umlClass, umlPackage)
			}
		}
	}
}

routine detectCompositeTypeClassCorrespondenceCandidates(uml::Class umlClass, uml::Package umlPackage){
	match{
		val pcmRepository = retrieve asserted pcm::Repository corresponding to umlPackage tagged with TagLiterals.REPOSITORY_TO_DATATYPES_PACKAGE
	}
	action{
		call{
			val candidates = pcmRepository.dataTypes__Repository.filter(CompositeDataType).filter[type | type.entityName == umlClass.name]
			switch (candidates.size){
				case 0: createCompositeTypeClassCorrespondence(umlClass, umlPackage)
				case 1: addCompositeTypeClassCorrespondence(candidates.head, umlClass)
				default: {
//					userDisambiguateCompositeTypeClassCorrespondenceCandidates(umlClass, umlPackage, candidates) //should not occure -> warning
					logger.warn("Found multiple possible CompositeDatatype correspondence candidates for a class <" + umlClass + "> in the datatypes package")
					addCompositeTypeClassCorrespondence(candidates.head, umlClass)
				}
			}
		}
	}
}

routine createCompositeTypeClassCorrespondence(uml::Class umlClass, uml::Package umlPackage){
	match{
		val pcmRepository = retrieve asserted pcm::Repository corresponding to umlPackage tagged with TagLiterals.REPOSITORY_TO_DATATYPES_PACKAGE
	}
	action{
		val pcmCompositeType = create pcm::CompositeDataType and initialize {
			pcmCompositeType.entityName = umlClass.name
			//TODO recurse generalizations for parent CompositeDataTypes
			//TODO recurse ownedProperties for inner declarations (DataTypes)
		}
		add correspondence between pcmCompositeType and umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		call moveCompositeTypeClassCorrespondence(umlClass, umlPackage)
	}
}

routine addCompositeTypeClassCorrespondence(pcm::CompositeDataType pcmCompositeType, uml::Class umlClass){
	action{
		add correspondence between pcmCompositeType and umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
	}
}

routine moveCompositeTypeClassCorrespondence(uml::Class umlClass, uml::Package umlPackage){
	match{
		val pcmCompositeType = retrieve asserted pcm::CompositeDataType corresponding to umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		val pcmRepository = retrieve asserted pcm::Repository corresponding to umlPackage tagged with TagLiterals.REPOSITORY_TO_DATATYPES_PACKAGE
	}
	action{
		update pcmCompositeType {
			pcmRepository.dataTypes__Repository += pcmCompositeType
		}
	}
}

reaction ClassRemovedFromPkg {
	after element uml::Class removed from uml::Package[packagedElement]
	with {oldValue.package !== affectedEObject}
	call disambiguateRemovedClassConcept(oldValue, affectedEObject)
}

routine disambiguateRemovedClassConcept(uml::Class umlClass, uml::Package umlPackage){
	match{
		val pcmCompositeType = retrieve optional pcm::CompositeDataType corresponding to umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		val pcmRepositoryComponent = retrieve optional pcm::RepositoryComponent corresponding to umlClass tagged with TagLiterals.REPOSITORY_COMPONENT_TO_CLASS
	}
	action{
		call {
			if (pcmRepositoryComponent.isPresent){
				//assume that the change is caused by the removal of pcmRepository type, and that the change is resolved
			}
			else if (pcmCompositeType.isPresent){
				removeCompositeTypeClassCorrespondence(umlClass, umlPackage)
			}
		}
	}
}

routine removeCompositeTypeClassCorrespondence(uml::Class umlClass, uml::Package umlPackage){
	match{
		val pcmCompositeType = retrieve pcm::CompositeDataType corresponding to umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		val pcmRepository = retrieve pcm::Repository corresponding to umlPackage tagged with TagLiterals.REPOSITORY_TO_DATATYPES_PACKAGE
	}
	action{
		update pcmCompositeType {
			pcmRepository.dataTypes__Repository -= pcmCompositeType
		}
	}
}

reaction ClassDeleted {
	after element uml::Class deleted
	call disambiguateDeletedClassConcept(affectedEObject)
}

routine disambiguateDeletedClassConcept(uml::Class umlClass){
	match{
		val pcmCompositeType = retrieve optional pcm::CompositeDataType corresponding to umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		val pcmRepositoryComponent = retrieve optional pcm::RepositoryComponent corresponding to umlClass tagged with TagLiterals.REPOSITORY_COMPONENT_TO_CLASS
	}
	action{
		call {
			if (pcmRepositoryComponent.isPresent){
				deleteRepositoryComponentImplCorrespondence(umlClass)
			}
			else if (pcmCompositeType.isPresent){
				deleteCompositeTypeClassCorrespondence(umlClass)
			}
		}
	}
}

routine deleteCompositeTypeClassCorrespondence(uml::Class umlClass){
	match{
		val pcmCompositeType = retrieve pcm::CompositeDataType corresponding to umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
	}
	action{
		remove correspondence between pcmCompositeType and umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		delete pcmCompositeType
	}
}

routine deleteRepositoryComponentImplCorrespondence(uml::Class umlClass){
	match{
		val pcmComponent = retrieve pcm::RepositoryComponent corresponding to umlClass tagged with TagLiterals.REPOSITORY_COMPONENT_TO_CLASS
	}
	action{
		remove correspondence between pcmComponent and umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		delete pcmComponent
	}
}


reaction ClassRenamed {
	after attribute replaced at uml::Class[name]
	with {affectedEObject.name == newValue}
	call disambiguateRenamedClassConcept(affectedEObject, newValue)
}

routine disambiguateRenamedClassConcept(uml::Class umlClass, String newName){
	match{
		val pcmCompositeType = retrieve optional pcm::CompositeDataType corresponding to umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		val pcmRepositoryComponent = retrieve optional pcm::RepositoryComponent corresponding to umlClass tagged with TagLiterals.REPOSITORY_COMPONENT_TO_CLASS
	}
	action{
		call {
			if (pcmRepositoryComponent.isPresent){
				renameRepositoryComponentImplCorrespondence(umlClass, newName)
			}
			else if (pcmCompositeType.isPresent){
				renameCompositeTypeClassCorrespondence(umlClass, newName)
			}
		}
	}
}

routine renameCompositeTypeClassCorrespondence(uml::Class umlClass, String newName){
	match{
		val pcmCompositeType = retrieve pcm::CompositeDataType corresponding to umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
	}
	action{
		update pcmCompositeType {
			pcmCompositeType.entityName = newName
		}
	}
}

routine renameRepositoryComponentImplCorrespondence(uml::Class umlClass, String newName){
	match{
		val pcmCompositeType = retrieve pcm::CompositeDataType corresponding to umlClass tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
	}
	action{
		update pcmCompositeType {
			pcmCompositeType.entityName = newName
		}
	}
}

//TODO generalization reaction and routine

reaction ClassGeneralizationAdded {
	after element uml::Generalization inserted in uml::Class[generalization]
	with {affectedEObject.generalizations.contains(newValue)} //validity check
	call addParentCollectionDatatype(affectedEObject, newValue.general)
}

routine addParentCollectionDatatype(uml::Class umlClass, uml::Classifier umlNewParent){
	match {
		val pcmComposite = retrieve pcm::CompositeDataType corresponding to umlClass
		val pcmParentComposite = retrieve pcm::CompositeDataType corresponding to umlNewParent
	}
	action {
		execute {
			if (!pcmComposite.parentType_CompositeDataType.contains(pcmParentComposite)){
				pcmComposite.parentType_CompositeDataType += pcmParentComposite
			}
		}
	}
}

reaction ClassGeneralizationRemoved {
	after element uml::Generalization removed from uml::Class[generalization]
	with {!affectedEObject.generalizations.contains(oldValue)} //validity check
	call removeParentCollectionDatatype(affectedEObject, oldValue.general)
}

routine removeParentCollectionDatatype(uml::Class umlClass, uml::Classifier umlOldParent){
	match {
		val pcmComposite = retrieve pcm::CompositeDataType corresponding to umlClass
		val pcmParentComposite = retrieve pcm::CompositeDataType corresponding to umlOldParent
	}
	action {
		execute {
			if (pcmComposite.parentType_CompositeDataType.contains(pcmParentComposite)){
				pcmComposite.parentType_CompositeDataType -= pcmParentComposite
			}
		}
	}
}

reaction ParentCollectionDatatypeReplaced {
	after element replaced at uml::Generalization[general]
	with {affectedEObject.specific instanceof org.eclipse.uml2.uml.Class}
//	with {affectedEObject.general === newValue} // delay validity check to ensure that the old parent interface is removed
	call replaceParentCollectionDatatype(affectedEObject, newValue, oldValue)
}

routine replaceParentCollectionDatatype(uml::Generalization gen, uml::Classifier umlNewParent, uml::Classifier umlOldParent){
	match {
		val pcmComposite = retrieve pcm::CompositeDataType corresponding to gen.specific tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		val pcmOldParent = retrieve optional pcm::CompositeDataType corresponding to umlOldParent tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
		val pcmNewParent = retrieve optional pcm::CompositeDataType corresponding to umlNewParent tagged with TagLiterals.COMPOSITE_DATATYPE__CLASS
	}
	action {
		call {
			if(pcmOldParent.isPresent){
				removeParentCollectionDatatype(gen.specific as org.eclipse.uml2.uml.Class, umlOldParent)
			}
			if (pcmNewParent.isPresent && gen.general === umlNewParent){ // delayed validity check
				addParentCollectionDatatype(gen.specific as org.eclipse.uml2.uml.Class, umlNewParent)
			}
		}
	}
}







