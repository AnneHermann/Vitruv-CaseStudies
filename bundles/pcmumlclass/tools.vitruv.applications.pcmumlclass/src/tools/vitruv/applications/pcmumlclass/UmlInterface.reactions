import tools.vitruv.applications.pcmumlclass.TagLiterals

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml 
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

reactions: umlInterfaceReactions
in reaction to changes in UML
execute actions in PCM


// generalization reactions and routines are handled by:
// 	- UmlArchitecturalInterfaceGeneralization.reactions

reaction InterfaceInserted {
	after element uml::Interface inserted in uml::Package[packagedElement]
	call disambiguateContextChange(newValue, affectedEObject)
}

routine disambiguateContextChange(uml::Interface umlInterface, uml::Package umlPackage){
	match {
		val inContractsPkg = retrieve optional pcm::Repository corresponding to umlPackage tagged with TagLiterals.REPOSITORY_TO_CONTRACTS_PACKAGE
		val isArchitectureInterface = retrieve optional pcm::OperationInterface corresponding to umlInterface tagged with TagLiterals.INTERFACE_TO_INTERFACE
	}
	action {
		call{
			if (inContractsPkg.isPresent && isArchitectureInterface.isPresent){
				moveInterfaceCorrespondence(umlInterface, umlPackage) 
			}	
			else if (inContractsPkg.isPresent && !isArchitectureInterface.isPresent){
				createInterfaceCorrespondence(umlInterface, umlPackage) 
			}
			else if (!inContractsPkg.isPresent && isArchitectureInterface.isPresent){
				deleteInterfaceCorrespondence(umlInterface) 
			}
		}
	}
}

routine createInterfaceCorrespondence(uml::Interface umlInterface, uml::Package umlPackage){
	action {
		val pcmInterface = create pcm::OperationInterface and initialize {
			pcmInterface.entityName = umlInterface.name
		}
		add correspondence between pcmInterface and umlInterface tagged with TagLiterals.INTERFACE_TO_INTERFACE
		call moveInterfaceCorrespondence(umlInterface, umlPackage)
	}
}

routine moveInterfaceCorrespondence(uml::Interface umlInterface, uml::Package umlPackage){
	match {
		val pcmRepository = retrieve asserted pcm::Repository corresponding to umlPackage tagged with TagLiterals.REPOSITORY_TO_CONTRACTS_PACKAGE
		val pcmInterface = retrieve asserted pcm::OperationInterface corresponding to umlInterface tagged with TagLiterals.INTERFACE_TO_INTERFACE
	}
	action {
		update pcmRepository {
			pcmRepository.interfaces__Repository += pcmInterface
		}
	}
}

reaction InterfaceRenamed {
	after attribute replaced at uml::Interface[name]
	with {affectedEObject.name == newValue} //validity check
	call renameInterfaceCorrespondence(newValue, affectedEObject)
}

routine renameInterfaceCorrespondence(String newName, uml::Interface umlInterface){
	match {
		val pcmInterface = retrieve pcm::OperationInterface corresponding to umlInterface tagged with TagLiterals.INTERFACE_TO_INTERFACE
	}
	action {
		update pcmInterface {
			pcmInterface.entityName = umlInterface.name
		}
	}
}

reaction InterfaceRemoved {
	after element uml::Interface removed from uml::Package[packagedElement]
	call removeInterfaceCorrespondence(oldValue, affectedEObject)
}

routine removeInterfaceCorrespondence(uml::Interface umlInterface, uml::Package umlPackage){
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to umlPackage tagged with TagLiterals.REPOSITORY_TO_CONTRACTS_PACKAGE
		val pcmInterface = retrieve pcm::OperationInterface corresponding to umlInterface tagged with TagLiterals.INTERFACE_TO_INTERFACE
	}
	action {
		update pcmRepository {
			pcmRepository.interfaces__Repository -= pcmInterface
		}
	}
}

reaction InterfaceDeleted {
	after element uml::Interface deleted
	call deleteInterfaceCorrespondence(affectedEObject)
}

routine deleteInterfaceCorrespondence(uml::Interface umlInterface){
	match {
		val pcmInterface = retrieve pcm::OperationInterface corresponding to umlInterface tagged with TagLiterals.INTERFACE_TO_INTERFACE
	}
	action {
		remove correspondence between pcmInterface and umlInterface tagged with TagLiterals.INTERFACE_TO_INTERFACE
		delete pcmInterface
	}
}
