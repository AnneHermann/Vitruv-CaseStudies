import tools.vitruv.applications.pcmumlclass.TagLiterals
import org.eclipse.uml2.uml.Interface

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml 
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

reactions: umlInterfaceReactions
in reaction to changes in UML
execute actions in PCM




reaction InterfaceInserted {
	after element uml::Interface inserted in uml::Package[packagedElement]
	call disambiguateContextChange(newValue, affectedEObject)
}

routine disambiguateContextChange(uml::Interface umlInterface, uml::Package umlPackage){
	match {
		val inContractsPkg = retrieve optional pcm::Repository corresponding to umlPackage tagged with TagLiterals.REPOSITORY_TO_CONTRACTS_PACKAGE
		val isArchitectureInterface = retrieve optional pcm::OperationInterface corresponding to umlInterface tagged with TagLiterals.INTERFACE_TO_INTERFACE
	}
	action {
		call{
			if (inContractsPkg.isPresent && isArchitectureInterface.isPresent){
				moveInterfaceCorrespondence(umlInterface, umlPackage) 
			}	
			else if (inContractsPkg.isPresent && !isArchitectureInterface.isPresent){
				createInterfaceCorrespondence(umlInterface, umlPackage) 
			}
			else if (!inContractsPkg.isPresent && isArchitectureInterface.isPresent){
				deleteInterfaceCorrespondence(umlInterface) 
			}
		}
	}
}

routine createInterfaceCorrespondence(uml::Interface umlInterface, uml::Package umlPackage){
	action {
		val pcmInterface = create pcm::OperationInterface and initialize {
			pcmInterface.entityName = umlInterface.name
		}
		add correspondence between pcmInterface and umlInterface tagged with TagLiterals.INTERFACE_TO_INTERFACE
		call moveInterfaceCorrespondence(umlInterface, umlPackage)
	}
}

routine moveInterfaceCorrespondence(uml::Interface umlInterface, uml::Package umlPackage){
	match {
		val pcmRepository = retrieve asserted pcm::Repository corresponding to umlPackage tagged with TagLiterals.REPOSITORY_TO_CONTRACTS_PACKAGE
		val pcmInterface = retrieve asserted pcm::OperationInterface corresponding to umlInterface tagged with TagLiterals.INTERFACE_TO_INTERFACE
	}
	action {
		update pcmRepository {
			pcmRepository.interfaces__Repository += pcmInterface
		}
	}
}

reaction InterfaceRenamed {
	after attribute replaced at uml::Interface[name]
	with {affectedEObject.name == newValue} //validity check
	call renameInterfaceCorrespondence(newValue, affectedEObject)
}

routine renameInterfaceCorrespondence(String newName, uml::Interface umlInterface){
	match {
		val pcmInterface = retrieve pcm::OperationInterface corresponding to umlInterface tagged with TagLiterals.INTERFACE_TO_INTERFACE
	}
	action {
		update pcmInterface {
			pcmInterface.entityName = umlInterface.name
		}
	}
}

reaction InterfaceRemoved {
	after element uml::Interface removed from uml::Package[packagedElement]
	call removeInterfaceCorrespondence(oldValue, affectedEObject)
}

routine removeInterfaceCorrespondence(uml::Interface umlInterface, uml::Package umlPackage){
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to umlPackage tagged with TagLiterals.REPOSITORY_TO_CONTRACTS_PACKAGE
		val pcmInterface = retrieve pcm::OperationInterface corresponding to umlInterface tagged with TagLiterals.INTERFACE_TO_INTERFACE
	}
	action {
		update pcmRepository {
			pcmRepository.interfaces__Repository -= pcmInterface
		}
	}
}

reaction InterfaceDeleted {
	after element uml::Interface deleted
	call deleteInterfaceCorrespondence(affectedEObject)
}

routine deleteInterfaceCorrespondence(uml::Interface umlInterface){
	match {
		val pcmInterface = retrieve pcm::OperationInterface corresponding to umlInterface tagged with TagLiterals.INTERFACE_TO_INTERFACE
	}
	action {
		remove correspondence between pcmInterface and umlInterface tagged with TagLiterals.INTERFACE_TO_INTERFACE
		delete pcmInterface
	}
}

reaction InterfaceGeneralizationAdded {
	after element uml::Generalization inserted in uml::Interface[generalization]
	with {affectedEObject.generalizations.contains(newValue)} //validity check
	call addParentInterface(affectedEObject, newValue.general)
}

routine addParentInterface(uml::Interface umlInterface, uml::Classifier umlNewParent){
	match {
		val pcmInterface = retrieve pcm::OperationInterface corresponding to umlInterface tagged with TagLiterals.INTERFACE_TO_INTERFACE
		val pcmNewParent = retrieve pcm::OperationInterface corresponding to umlNewParent tagged with TagLiterals.INTERFACE_TO_INTERFACE
	}
	action {
		execute {
			if (!pcmInterface.parentInterfaces__Interface.contains(pcmNewParent)){
				pcmInterface.parentInterfaces__Interface += pcmNewParent
			}
		}
	}
}

reaction InterfaceGeneralizationRemoved {
	after element uml::Generalization removed from uml::Interface[generalization]
	with {!affectedEObject.generalizations.contains(oldValue)} //validity check
	call removeParentInterface(affectedEObject, oldValue.general)
}

routine removeParentInterface(uml::Interface umlInterface, uml::Classifier umlOldParent){
	match {
		val pcmInterface = retrieve pcm::OperationInterface corresponding to umlInterface tagged with TagLiterals.INTERFACE_TO_INTERFACE
		val pcmOldParent = retrieve pcm::OperationInterface corresponding to umlOldParent tagged with TagLiterals.INTERFACE_TO_INTERFACE
	}
	action {
		execute {
			if (pcmInterface.parentInterfaces__Interface.contains(pcmOldParent))
				pcmInterface.parentInterfaces__Interface -= pcmOldParent
		}
	}
}

reaction ParentInterfaceReplaced {
	after element replaced at uml::Generalization[general]
	with {affectedEObject.specific instanceof org.eclipse.uml2.uml.Interface}
//	with {affectedEObject.general === newValue} // delay validity check to ensure that the old parent interface is removed
	call replaceParentInterface(affectedEObject, newValue, oldValue)
}

routine replaceParentInterface(uml::Generalization gen, uml::Classifier newParent, uml::Classifier oldParent){
	match {
		val pcmInterface = retrieve pcm::OperationInterface corresponding to gen.specific tagged with TagLiterals.INTERFACE_TO_INTERFACE
		val pcmNewParent = retrieve optional pcm::OperationInterface corresponding to newParent tagged with TagLiterals.INTERFACE_TO_INTERFACE
		val pcmOldParent = retrieve optional pcm::OperationInterface corresponding to oldParent tagged with TagLiterals.INTERFACE_TO_INTERFACE
	}
	action {
		call {
			removeParentInterface(gen.specific as org.eclipse.uml2.uml.Interface, oldParent)
			if (gen.general === newParent){ // delayed validity check
				addParentInterface(gen.specific as org.eclipse.uml2.uml.Interface, newParent)
			}
		}
	}
}




