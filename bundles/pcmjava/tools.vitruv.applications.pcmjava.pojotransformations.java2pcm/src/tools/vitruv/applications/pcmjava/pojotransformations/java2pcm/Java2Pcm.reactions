import static extension tools.vitruv.domains.java.util.JavaPersistenceHelper.*
import org.palladiosimulator.pcm.repository.Repository
import org.palladiosimulator.pcm.system.System
import java.util.Set
import java.util.HashSet
import org.palladiosimulator.pcm.repository.BasicComponent
import org.palladiosimulator.pcm.repository.CompositeComponent
import java.util.List
import java.util.ArrayList
import tools.vitruv.framework.userinteraction.UserInteractionType

import "http://www.emftext.org/java" as java
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

reactions: java2pcm
in reaction to changes in Java
execute actions in PCM

///Repository

// TODO: Ensure that this reaction does only handle the creation of the repository root package 
reaction CreatePackage {
	after element java::Package inserted as root
	with !newValue.name.contains("contracts") && !newValue.name.contains("datatypes")
		call {
			val javaPackage = newValue
			createPCMRepository(javaPackage, javaPackage.name, "package_root")
			createJavaSubPackages(javaPackage)
		}
}

routine createPCMRepository(EObject sourceElementMappedToRepository, String packageName, String newTag) {
	match {
		require absence of pcm::Repository corresponding to sourceElementMappedToRepository tagged with newTag
	}
	action {
		val pcmRepository = create pcm::Repository and initialize {
			pcmRepository.entityName = packageName
			persistProjectRelative(sourceElementMappedToRepository, pcmRepository, "model/" + pcmRepository.entityName + ".repository")
		}
		
		add correspondence between pcmRepository and sourceElementMappedToRepository 
			tag with newTag
	}
}

//Component

reaction CreateSubPackage { 
	after element java::Package inserted in java::Package
	with !newValue.name.contains("contracts") && !newValue.name.contains("datatypes")
		call {
			// Let user select the class to map the collection type to
			var Set<Class<?>> architecturalElements = new HashSet
			architecturalElements += #[BasicComponent, CompositeComponent, System, null]
			val List<String> architecturalElementsNames = new ArrayList<String>(architecturalElements.size)
			for (architecturalElement : architecturalElements) {
				architecturalElementsNames.add(architecturalElement.name)
			}
			val String selectElementMsg = "A package has been created. Please decide whether and which corresponding architectural element should be created"
			val int selectedType = userInteracting.selectFromMessage(UserInteractionType.MODAL, selectElementMsg,
				architecturalElementsNames)
			
			if (selectedType == 0) {
				createBasicComponent(newValue)
			} else if (selectedType == 1) {
				createCompositeComponent(newValue)
			} else if (selectedType == 2) {
				createSystem(newValue)
			} else if (selectedType == 3) {
				//nothing
			}
		}
	
}

routine createSystem(java::Package javaPackage) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to javaPackage
	}
	action {
		val pcmSystem = create pcm::System and initialize {
			pcmSystem.entityName = javaPackage.name
		}
		add correspondence between pcmSystem and javaPackage
	}
}
routine createBasicComponent(java::Package javaPackage) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to javaPackage
	}
	action {
		val pcmBasicComponent = create pcm::BasicComponent and initialize {
			pcmBasicComponent.entityName = javaPackage.name
		}
		add correspondence between pcmBasicComponent and javaPackage
	}
}
routine createCompositeComponent(java::Package javaPackage) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to javaPackage
	}
	action {
		val pcmCompositeComponent = create pcm::CompositeComponent and initialize {
			pcmCompositeComponent.entityName = javaPackage.name
		}
		
		add correspondence between pcmCompositeComponent and javaPackage
	}
}


///Interface

// TODO error + how to ensure package is contracts tagged with?
reaction CreateInterface {
	after element java::Interface inserted in java::Package 
		call createPCMInterface(newValue)		
		
}

routine createPCMInterface(java::Interface javaIface) {
	match {
		val ifacePackage = retrieve java::Package corresponding to javaIface tagged with "contracts"
		val pcmRepository = retrieve pcm::Repository corresponding to ifacePackage
	}
	action {
		val pcmIface = create pcm::OperationInterface and initialize {
			pcmIface.entityName = javaIface.name
		}
		add correspondence between pcmIface and javaIface
	}
}

//DataType

// TODO error + how to ensure package is datatypes
reaction CreateClass {
	after element java::Class inserted in java::Package
	call createCompositeDataType(newValue)
	
}

routine createCompositeDataType(java::Class cls) {
	match {
		val clsPackage = retrieve java::Package corresponding to cls tagged with "datatypes"
		val pcmRepository = retrieve pcm::Repository corresponding to clsPackage
	}
	action {
		val pcmCompositeDataType = create pcm::CompositeDataType and initialize {
			pcmCompositeDataType.entityName = cls.name
		}
		add correspondence between pcmCompositeDataType and cls
	}
}


//Other
routine createJavaSubPackages(java::Package javaPackage) {
	match {
		val repository = retrieve pcm::Repository corresponding to javaPackage
	}
	action {
		call {
			createJavaPackage(repository, javaPackage, "datatypes", "datatypes");
			createJavaPackage(repository, javaPackage, "contracts", "contracts");
		}
	}
}	

routine createJavaPackage(EObject sourceElementMappedToPackage, java::Package parentPackage, String packageName, String newTag)	 { 
	match {
		require absence of java::Package corresponding to sourceElementMappedToPackage tagged with newTag
	} 
	action { 
		val javaPackage = create java::Package and initialize {
			if (parentPackage !== null) {
				javaPackage.namespaces += parentPackage.namespaces;
				javaPackage.namespaces += parentPackage.name; 
			}
			javaPackage.name = packageName;
			persistProjectRelative(parentPackage, javaPackage, buildJavaFilePath(javaPackage));
		}
		add correspondence between javaPackage and sourceElementMappedToPackage
			tag with newTag
	}
}
