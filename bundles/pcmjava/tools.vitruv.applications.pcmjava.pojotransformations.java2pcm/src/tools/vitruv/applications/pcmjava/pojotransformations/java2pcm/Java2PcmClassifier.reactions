import tools.vitruv.framework.userinteraction.UserInteractionType

import static extension tools.vitruv.applications.pcmjava.pojotransformations.java2pcm.Java2PcmHelper.*
import static extension tools.vitruv.domains.java.util.JavaPersistenceHelper.*

import "http://www.emftext.org/java" as java
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

reactions: Java2PcmClassifier
in reaction to changes in Java
execute actions in PCM

///Repository
// TODO: Ensure that this reaction does only handle the creation of the repository root package 
reaction PackageCreated {
	after element java::Package inserted as root
	with !newValue.name.contains("contracts") && !newValue.name.contains("datatypes")
		
	call {
		if (noCorrespondenceRepository(correspondenceModel)) {
			val javaPackage = newValue
			createPCMRepository(javaPackage, javaPackage.name, "package_root")
			createJavaSubPackages(javaPackage)
		} else {
			createArchitecturalElement(newValue)
		}
	}

}

routine createArchitecturalElement(java::Package javaPackage) {
	action {
		call {
			val String userMsg = "A package has been created. Please decide whether and which corresponding architectural element should be created"
			val String[] selections = #["Create basic component", "Create composite component", "Create system",
										"Do nothing/Decide later"]
			val selected = userInteracting.selectFromMessage(UserInteractionType.MODAL, userMsg, selections)
			switch(selected) {
				case 0: createBasicComponent(javaPackage) 
				case 1: createCompositeComponent(javaPackage)
				case 2: createSystem(javaPackage)
			}
		}
	}
}

routine createPCMRepository(EObject sourceElementMappedToRepository, String packageName, String newTag) {
	match {
		require absence of pcm::Repository corresponding to sourceElementMappedToRepository tagged with newTag
	}
	action {
		val pcmRepository = create pcm::Repository and initialize {
			pcmRepository.entityName = packageName
			persistProjectRelative(sourceElementMappedToRepository, pcmRepository, "model/" + pcmRepository.entityName + ".repository")
		}
		
		add correspondence between pcmRepository and sourceElementMappedToRepository 
			tag with newTag
	}
}


//Component


routine createSystem(java::Package javaPackage) {
	action {
		val pcmSystem = create pcm::System and initialize {
			pcmSystem.entityName = getLastPackageName(javaPackage.name)
			persistProjectRelative(javaPackage, pcmSystem, "model/" + pcmSystem.entityName + ".system")
		}
		add correspondence between pcmSystem and javaPackage
	}
}

routine createBasicComponent(java::Package javaPackage) {
	action {
		val pcmBasicComponent = create pcm::BasicComponent and initialize {
			pcmBasicComponent.entityName = getLastPackageName(javaPackage.name)
		}
		add correspondence between pcmBasicComponent and javaPackage
		
		call addComponentToRepository(pcmBasicComponent, findPcmRepository(correspondenceModel, javaPackage.name))
		
	}
}

routine createCompositeComponent(java::Package javaPackage) {
	action {
		val pcmCompositeComponent = create pcm::CompositeComponent and initialize {
			pcmCompositeComponent.entityName = getLastPackageName(javaPackage.name)
		}
		add correspondence between pcmCompositeComponent and javaPackage
		
		call addComponentToRepository(pcmCompositeComponent, findPcmRepository(correspondenceModel, javaPackage.name))
	}
}

routine addComponentToRepository(pcm::ImplementationComponentType pcmComponent, pcm::Repository pcmRepository) {
	action {
		update pcmRepository {
			pcmRepository.components__Repository += pcmComponent
		}
	}
}
routine addInterfaceToRepository(pcm::OperationInterface pcmInterface, pcm::Repository pcmRepository, java::Interface javaInterface, java::CompilationUnit compilationUnit) {
	action {
		
		add correspondence between pcmInterface and javaInterface
		add correspondence between pcmInterface and compilationUnit	
			
		update pcmRepository {
			pcmRepository.interfaces__Repository += pcmInterface
		}
	}
}


reaction CreateInterface {
	after element java::Interface inserted in java::CompilationUnit[classifiers]
	call createPCMInterface(newValue, affectedEObject)		
}

routine createPCMInterface(java::Interface javaInterface, java::CompilationUnit compilationUnit) {
	action {
		val pcmIface = create pcm::OperationInterface and initialize {
			pcmIface.entityName = javaInterface.name
		}		
		call {
			if (!compilationUnit.namespaces.last.equals("contracts")) {
				val String userMsg = "The created interface is not in the contracts packages. Should an architectural interface be created for the interface " +
					javaInterface.name + " ?"
				val String[] selections = #["yes", "no"]
				val selected = userInteracting.selectFromMessage(UserInteractionType.MODAL, userMsg, selections)
				if (selected == 0) {
					val repo = findPcmRepository(correspondenceModel, compilationUnit.namespaces.head)
					addInterfaceToRepository(pcmIface, repo, javaInterface, compilationUnit)
				}
			} else {
				val repo = findPcmRepository(correspondenceModel, compilationUnit.namespaces.head)
				addInterfaceToRepository(pcmIface, repo, javaInterface, compilationUnit)
			}
		}
	}
}


routine addCorrespondence(pcm::OperationInterface pcmInterface, java::Interface javaInterface, java::CompilationUnit compilationUnit) {
	action {
		add correspondence between pcmInterface and javaInterface
		add correspondence between pcmInterface and compilationUnit		
	}
}



//DataType

// TODO error + how to ensure package is datatypes
reaction CreateClass {
	after element java::Class inserted in java::CompilationUnit[classifiers]
	call {
		if (affectedEObject.namespaces.last.equals("contracts")) {
			createCompositeDataType(newValue, affectedEObject)			
		} else {
			val package = getContainingPackageFromCorrespondanceModel(newValue, correspondenceModel)
		if (package !== null) {
			createArchitecturalElement(package)
		}
		}//else if hat package correspondirte klasse?
		//else if keine correspondance -> basic/composite component oder system
	}
	
}

routine createCompositeDataType(java::Class cls, java::CompilationUnit compilationUnit) {
	action {
		val pcmCompositeDataType = create pcm::CompositeDataType and initialize {
			pcmCompositeDataType.entityName = cls.name
			pcmCompositeDataType.repository__DataType = null
		}
		
		add correspondence between pcmCompositeDataType and cls
		add correspondence between compilationUnit and cls
		
		call {
			val repo = findPcmRepository(correspondenceModel, compilationUnit.namespaces.head)
			addDataTypeInRepository(repo, pcmCompositeDataType)
		}
	}
}

routine addDataTypeInRepository(pcm::Repository pcmRepository, pcm::CompositeDataType pcmDataType) {
	action {
		update pcmRepository {
			pcmRepository.dataTypes__Repository += pcmDataType
		}
	}
}


//Other
routine createJavaSubPackages(java::Package javaPackage) {
	match {
		val repository = retrieve pcm::Repository corresponding to javaPackage
	}
	action {
		call {
			createJavaPackage(repository, javaPackage, "datatypes", "datatypes");
			createJavaPackage(repository, javaPackage, "contracts", "contracts");
		}
	}
}	

routine createJavaPackage(EObject sourceElementMappedToPackage, java::Package parentPackage, String packageName, String newTag)	 { 
	match {
		require absence of java::Package corresponding to sourceElementMappedToPackage tagged with newTag
	} 
	action { 
		val javaPackage = create java::Package and initialize {
			if (parentPackage !== null) {
				javaPackage.namespaces += parentPackage.namespaces;
				javaPackage.namespaces += parentPackage.name; 
			}
			javaPackage.name = packageName;
			persistProjectRelative(parentPackage, javaPackage, buildJavaFilePath(javaPackage));
		}
		add correspondence between javaPackage and sourceElementMappedToPackage
			tag with newTag
	}
}
